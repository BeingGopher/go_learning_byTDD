# MySQL

## 数据库三大范式是什么  

数据库三范式（1NF、2NF、3NF）是关系型数据库设计中用于规范数据表结构、减少数据冗余、提高数据一致性的重要准则，以下为你详细介绍：

### 第一范式（1NF）
• **定义**：确保每列的原子性，即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，也不能将多组数据存储在同一单元格内。
 • **示例**：
    ◦ 假设有一个学生信息表，其中有一个“联系方式”字段，用来记录学生的电话和邮箱。如果存在某条记录在该字段中同时写入了电话号码“138xxxxxxxx”和邮箱“abc@example.com”，这就不符合第一范式。
    ◦ 符合第一范式的设计应该是将“联系方式”拆分为“电话号码”和“电子邮箱”两个独立的字段，每个字段只存储单一类型的数据。

### 第二范式（2NF）
 • **定义**：在满足第一范式的基础上，要求表中的每一列都和主键相关，而不是只和主键的一部分相关（针对联合主键而言）。也就是说，非主属性必须完全依赖于整个候选键。
 • **示例**：
    ◦ 假设有一个选课表，包含字段（学号，课程号，学生姓名，课程名称，成绩）。这里（学号，课程号）作为联合主键。其中“学生姓名”只依赖于“学号”，“课程名称”只依赖于“课程号”，而不依赖于整个联合主键（学号，课程号），存在部分依赖关系，不符合第二范式。
    ◦ 可以将其拆分为三个表：学生表（学号，学生姓名）、课程表（课程号，课程名称）和选课成绩表（学号，课程号，成绩）。这样每个非主属性都完全依赖于各自表的主键。

### 第三范式（3NF）
 • **定义**：在满足第二范式的基础上，消除主属性对主键的传递依赖。即非主属性不能依赖于其他非主属性。
 • **示例**：
    ◦ 假设有一个员工信息表，包含字段（员工编号，部门编号，部门经理，员工姓名）。其中（员工编号）为主键，“部门经理”通过“部门编号”与“员工编号”产生传递依赖（员工编号→部门编号，部门编号→部门经理），不符合第三范式。
    ◦ 可以将其拆分为两个表：员工表（员工编号，部门编号，员工姓名）和部门表（部门编号，部门经理）。这样就消除了传递依赖，符合第三范式的要求 。

## MySQL 有关权限的表都有哪几个？ 
MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 MySQL 数 据库里，由 
mysql_install_db 脚本初始化。这些权限表分别 user，db， table_priv，columns_priv 和 host。下面
分别介绍一下这些表的结构和内容： 

1. user 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。 
2. db 权限表：记录各个帐号在各个数据库上的操作权限。 
3. table_priv 权限表：记录数据表级的操作权限。 
4. columns_priv 权限表：记录数据列级的操作权限。 
5. host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控 制。这个权限表不受 
GRANT 和 REVOKE 语句的影响。 

## MySQL 的 Binlog 有有几种录入格式？分别有什么区别？  
有三种格式，statement，row 和 mixed。 

1. statement 模式下，每一条会修改数据的 SQL 都会记录在 Binlog 中。不需 要记录每一行的变化，
减少了 Binlog 日志量，节约了 IO，提高性能。由于 sql 的执行是有上下文的，因此在保存的时候
需要保存相关的信息，同时还 有一些使用了函数之类的语句无法被记录复制。 
2. row 级别下，不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。记 录单元为每一行的改
动，基本是可以全部记下来但是由于很多操作，会导 致大量行的改动(比如 alter table)，因此这种
模式的文件保存的信息太 多，日志量太大。 
3. mixed，一种折中的方案，普通操作使用 statement 记录，当无法使用 statement 的时候使用 row 

## MySQL 存储引擎 MyISAM 与 InnoDB 区别

**1. 事务支持**  
- **InnoDB**：支持事务，提供 ACID（原子性、一致性、隔离性、持久性）特性，适合需要事务处理的场景，如金融系统。
- **MyISAM**：不支持事务，无法保证事务的完整性。

**2. 锁机制**  
- **InnoDB**：采用行级锁，锁定数据行，适合高并发的读写操作，减少锁冲突。
- **MyISAM**：采用表级锁，锁定整个表，适合读多写少的场景，写操作时并发性能较差。

**6. 内存占用和性能**  
- **InnoDB**：内存占用相对较高，但性能稳定，适合复杂事务处理。
- **MyISAM**：内存占用低，读取速度快，但不适合写密集型场景。

**7. 数据恢复**  
- **InnoDB**：支持崩溃恢复，可自动修复数据。
- **MyISAM**：无自动恢复机制，数据损坏后恢复较困难。

## MyISAM 索引与 InnoDB 索引的区别？   

1. InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。 
2. InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。 
3. MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。 
4. InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会
非常高效。

## 什么是索引 
索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所
有记录的引用指针。 索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以
协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变 种 B+树。 更通俗的说，索引就
相当于目录。为了方便查找书中的内容，通过对内容建立 索引形成目录。索引是一个文件，它是要占据
物理空间的。

## 索引有哪些优缺点 
索引的优点 

1. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 

2. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

  索引的缺点 

3. 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进 行增加、删除和修改的时
  候，索引也要动态的维护，会降低增/改/删的执 行效率； 

4. 空间方面：索引需要占物理空间

## 索引有哪几种类型？

1. **普通索引（Normal Index）**  
   最基本的索引类型，无特殊限制，可用于加速查询。
2. **唯一索引（Unique Index）**  
   索引列中的值必须唯一，但允许有空值（NULL）。用于确保数据的唯一性。
3. **主键索引（Primary Key Index）**  
   特殊的唯一索引，表中只能有一个主键索引，且主键列不允许有空值。主键索引通常用于唯一标识表中的每一行。
4. **组合索引（Composite Index）**  
   包含多个列的索引，可以提高多列查询的效率。查询时，组合索引的列顺序很重要。
5. **全文索引（Full-Text Index）**  
   用于全文搜索，支持对文本内容的快速检索。仅支持某些存储引擎（如 InnoDB 和 MyISAM）。

## MySQL 中有哪几种锁？   

1. 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 
2. 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 
3. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发
度一般。  

## MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级 之间的区别？  

1. read uncommited：读到未提交数据 
3. read committed：脏读，不可重复读 
4. repeatable read：可重读 
5. serializable：串行事物 

 ## char 和 varchar 的区别？   

### 1. **存储方式**
- **`CHAR`**：固定长度字符串。无论实际存储的数据长度如何，都会占用指定的全部长度。如果存储的数据不足指定长度，会用空格填充。
- **`VARCHAR`**：可变长度字符串。存储时只占用实际数据长度加上一个额外的字节（用于记录数据的实际长度）。

### 2. **性能**
- **`CHAR`**：读取速度快，因为存储是固定的，MySQL 可以快速定位数据。
- **`VARCHAR`**：写入速度快，因为只占用实际需要的空间，但读取时可能需要额外计算长度。

### 3. **存储空间**
- **`CHAR`**：浪费空间，尤其是当字段长度远大于实际数据长度时。
- **`VARCHAR`**：节省空间，但会占用额外的字节来记录长度。

### 4. **适用场景**
- **`CHAR`**：适用于长度固定或长度差异很小的字段，如手机号码、身份证号、国家代码等。
- **`VARCHAR`**：适用于长度差异较大的字段，如用户名、地址、描述等。

### 5. **排序和比较**
- **`CHAR`**：在排序和比较时，会考虑尾部的空格。
- **`VARCHAR`**：在排序和比较时，不会考虑尾部的空格。

## 主键和候选键有什么区别？ 

表格的每一行都由主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定
为主键，并且可以用于任何外 键引用  

候选键都能唯一标识元组，主键是候选键中被选中用于唯一标识元组的那个，一个表只有一个主键，但可有多个候选键 。

## 如何在 Unix 和 MySQL 时间戳之间进行转换？ 

UNIX_TIMESTAMP 是从 MySQL 时间戳转换为 Unix 时间戳的命令 FROM_UNIXTIME 是从 Unix 时间戳
转换为 MySQL 时间戳的命令  

## MyISAM 表类型将在哪里存储，并且还提供其存储格式？ 

每个 MyISAM 表格以三种格式存储在磁盘上：

1. “.frm”文件 存储表定义
2. 数据文件具有“.MYD”（MYData）扩展名 
3. 索引文件具有“.MYI”（MYIndex）扩展名 

## MySQL 里记录货币用什么字段类型好

DECIMAL类型较好。它能精确表示小数，可指定精度（总位数）和标度（小数位数），适合存储货币金额 。

## 创建索引时需要注意什么？  

1. 非空字段：应该指定列为 NOT NULL，除非你想存储 NULL。在 MySQL 中，含 有空值的列很难进
行查询优化，因为它们使得索引、索引的统计信息以及 比较运算更加复杂。应该用 0、一个特殊的
值或者一个空串代替空值； 
2. 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引 的前面，可以通过 
count()函数查看字段的差异值，返回值越大说明字段的 唯一值越多字段的离散程度高； 
3. 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一 次 I/O 操作获取的数据越
大效率越高  

## 使用索引查询一定能提高查询的性能吗？为什么 

不一定。如果查询条件涉及大量数据行且索引选择性低（即索引列不同值较少），或者查询需要回表操作（如覆盖索引未包含所有查询列），可能导致索引查询性能不如全表扫描 。

## 百万级别或以上的数据如何删除

 关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所 以当我们对数据的增加,修
改,删除,都会产生额外的对索引文件的操作,这些操 作需要消耗额外的 IO,会降低增/改/删的执行效率。所
以，在我们删除数据库 百万级别数据的时候，查询 MySQL 官方手册得知删除数据的速度和创建的索引 
数量是成正比的。 

1. 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多 钟） 
2. 然后删除其中无用数据（此过程需要不到两分钟） 
3. 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟 左右。 
4. 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回 滚。那更是坑了。

## 什么是最左前缀原则？什么是最左匹配原则  

顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where 子句 中使用最频繁的一列放在
最左边。 

最左前缀匹配原则，非常重要的原则，MySQL 会一直向右匹配直到遇到范围查 询(>、<、
between、like)就停止匹配，比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d 
是用不到索引的，如果建立 (a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。 =和 in 可以乱
序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任 意顺序，MySQL 的查询优化器会帮你优化成
索引可以识别的形式。  

## 什么是聚簇索引？何时使用聚簇索引与非聚簇索引  

1. 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 
2. 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam 通
过 key_buffer 把索引先缓存到内存中，当需要访问 数据时（通过索引访问数据），在内存中直接
搜索索引，然后通过索引找 到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢
的 原因。  

## MySQL 连接器 

首先需要在 MySQL 客户端登陆才能使用，所以需要 个连接器 来连接用户和 MySQL 数据库，我们 一般
是使用 mysql-u 用户名-p 密码 
来进行 MySQL 登陆，和服务端建立连接。在完成 TCP 握手后，连接器会根据你 输入的用户名和密码验
证你的登录身份。如果用户名或者密码错误，MySQL 就 会提示 Access denied for user，来结束执行。
如果登录成功后，MySQL 会根 据权限表中的记录来判定你的权限。 

## MySQL 查询缓存  

MySQL 在得到一个执行请求后，会首先去查询缓存 中查找，是否执行过这条 SQL 语句，之前执行过的语句以及结果会以 keyvalue 对的形式，被直接放在 内存中。key 是查询语句，value 是查询的结果。 如果通过 key 能够查找到这条 SQL 语句，就直接返回 SQL 的执行结果。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果 就会被放入查询缓存中。 可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直 接返回结果，效率会很高。

## 什么是临时表，何时删除临时表？ 

什么是临时表?MySQL 在执行 SQL 语句的过程中 通常会临时创建一些存储中间 结果集的表，临时 表只
对当前连接可见，在连接关闭时，临时表会被删除并 释放所有表空间。 临时表分为两种:一种是内存临时
表，一种是磁盘临时表，什么区别呢?内存临 时表使用的是 MEMORY 存储引擎，而临时表采用的是 
MylSAM 存储引擎。 MySQL 会在下面这几种情况产生临时表。 

1. 使用 UNION 查询:UNION 有两种，一种是 UNION，一种是 UNION ALL，它们 都用于联合查询;区
别是使用 UNION 会去掉两个表中的重复数据，相当于对 结果集做了一下 去重(distinct)。使用 
UNIONALL，则不会排重，返回所有 的行。使用 UNION 查询会产生临时表。 
2. 使用 TEMPTABLE 算法或者是 UNION 查询中的视图。TEMPTABLE 算法是一种创 建临时表的算
法，它是将结果放置到临时表中，意味这要 MySQL 要先创建 好一个临时表，然后将结果放到临时
表中去，然后再使用这个临时表进行 相应的查询。 
3. ORDER BY 和 GROUPBY 的子句不一样时也会产生临时表。
4. DISTINCT 查询并且加上 ORDER BY 时;
 5. SQL 中用到 SQL_SMALL_RESULT 选项时;如果查询结果比较小的时候，可以加 上 SQL SMALL 
RESULT 来优化，产生临时表 
6. FROM 中的子查询; 
7. EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 Using Temporary 就 表示会用到临时表 

## 谈谈 SQL 优化的经验  

1. 查询语句无论是使用哪种判断条件等于、小于、大于，WHERE 左侧的条件 查询字段不要使用函数
或者表达式 
2. 使用 EXPLAIN 命令优化你的 SELECT 查询，对于复杂、效率低的 SQL 语 句，我们通常是使用 
explainsql 来分析这条 SQL 语句，这样方便我们分 析，进行优化。 
3. 当你的 SELECT 查询语句只需要使用一条记录时，要使用 LIMIT 1。不要 直接使用 SELECT*，而应
该使用具体需要查询的表字段，因为使用 EXPLAIN 进行分析时，SELECT"使用的是全表扫描，也就
是 type =all 。 
4. 为每一张表设置一个 ID 属性。 
5. 避免在 MHERE 字句中对字段进行 NULL 
6. 判断避免在 WHERE 中使用!或>操作符 
7. 使用 BETWEEN AND 替代 IN 
8. 为搜索字段创建索引 
9. 选择正确的存储引擎，InnoDB、MyISAM、MEMORY 等 
10. 使用 LIKE%abc%不会走索引，而使用 LIKE abc%会走索引。 
11. 对于枚举类型的字段(即有固定罗列值的字段)，建议使用 ENUM 而不是 VARCHAR，如性别、星
期、类型、类别等。 
12. 拆分大的 DELETE 或 INSERT 语句 
13. 选择合适的字段类型，选择标准是尽可能小、尽可能定长、尽可能使用整 数。 
14. 字段设计尽可能使用 NOT NULL 
15. 进行水平切割或者垂直分割

## 什么叫外链接？ 

外连接分为三种，分别是是左外连接(LEFT OUTER J0IN 或 LEFT JOIN 右外连 接(RIGHT OUTER JOIN 或 
RIC GHT JOIN、全外连接(FULL OUTER JOIN 或 FULLJOIN)。 左外连接:又称为左连接，这种连接方式会
显示左表不符合条件的数据行，右边 不符合条件的数据行直接显示 NULL。 右外连接:也被称为右连接，
他与左连接相对，这种连接方式会显示右表不符合 条件的数据行，左表不符合条件的数据行直接显示 
NULL  

## 什么叫内链接？ 
结合两个表中相同的字段，返回关联字段相符的记录就是内链接  

## 使用 union 和 union all 时需要注意些什么？ 

通过 union 连接的 SQL 分别单独取出的列数必须相同。 使用 union 时，多个相等的行将会被合并，由
于合升比较耗时，一般不直接使 用 union 进行合并，而是通常采用 union all 进行合并。

## MyISAM 存储引擎的特点，InnoDB 存储引擎的特点

### MyISAM
• **不支持事务**：无法保证数据的原子性、一致性等事务特性。
 • **表级锁**：并发写入性能较差，一个写操作会锁住整个表。
 • **存储限制**：支持全文索引，在早期对文本搜索有优势，数据文件和索引文件分开存储。
 • **外键不支持**：无法通过引擎层面保证数据的参照完整性。

### InnoDB（现在MySQL的默认索引）
 • **支持事务**：遵循 ACID 特性，提供可靠的事务处理能力。
 • **行级锁**：并发性能好，只锁定操作的行，减少锁冲突。
 • **支持外键**：通过外键约束维护数据的参照完整性。
 • **数据和索引存储**：数据和索引存储在一个.ibd 文件中（共享表空间模式下也有相关配置差异） 。

