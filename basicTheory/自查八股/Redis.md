# Redis

## 什么是 Redis?

Redis 是一个开源的高性能键值对（Key-Value）内存数据库，也被称为数据结构服务器。

### 主要特点
• **速度快**：基于内存操作，读写速度极快，单机能够达到每秒数万次的读写操作。
 • **数据结构丰富**：支持多种数据结构，如字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set） 等，能满足不同场景需求。
 • **持久化**：支持两种持久化方式，RDB（Redis Database）快照和 AOF（Append Only File）日志 ，可将内存中的数据保存到磁盘，方便在服务器重启后恢复数据。
 • **分布式**：可通过集群模式（如 Redis Cluster）实现分布式存储和处理，轻松应对大规模数据和高并发访问。 

### 应用场景
• **缓存**：作为缓存中间件，减轻后端数据库压力，加速数据读取，提升系统整体性能。
 • **消息队列**：利用列表等数据结构实现简单的消息队列功能，用于异步处理和解耦系统组件。 
 • **计数器**：借助 Redis 的原子操作，可方便地实现各种计数器功能，如网站访问量统计、点赞数统计等 。 
 • **分布式锁**：通过SETNX（SET if Not eXists）等命令实现分布式锁，保证在分布式环境下数据的一致性和操作的原子性 。

## Redis 与其他 key-value 存储有什么不同？

| 对比维度         | Redis                                                        | 其他key - value存储（以常见类型为例）                        |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **数据结构**     | 支持丰富数据结构，如字符串、哈希、列表、集合、有序集合等，可对结构执行复杂操作 | 大多仅支持简单键值对，键和值为字节串，操作围绕简单读写       |
| **内存与持久化** | 数据主存内存，读写快；支持RDB快照和AOF日志持久化，可灵活选择或结合 | 部分基于磁盘持久化，内存作缓存加速读写；持久化机制和内存管理策略有别 |
| **功能特性**     | 有发布/订阅模式、事务（简化版）、Lua脚本功能                 | 多数专注基本键值存取，高级特性欠缺                           |
| **性能与扩展性** | 单线程处理高并发出色，通过集群模式（如Redis Cluster）可水平扩展 | 不同实现有差异，有的多线程/进程追求写入性能，扩展方式和复杂操作支持不如Redis |

## 使用 Redis 有哪些好处？

1. 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查 找和操作的时间复杂
度都是 O1) 
2. 支持丰富数据类型，支持 string，list，set，Zset，hash 等 
3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执 行，要么全部不执行 
4. 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除

## Redis 相比 Memcached 有哪些优势？ 

| 对比维度     | Redis                                                        | Memcached                                                  | Redis优势说明                                                |
| ------------ | ------------------------------------------------------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| **数据结构** | 支持丰富的数据结构，如字符串、哈希、列表、集合、有序集合等   | 仅支持简单的键值对存储                                     | Redis能满足更多样化的数据处理需求，可直接对复杂结构进行操作，而Memcached只能进行简单存取 |
| **持久化**   | 支持RDB快照和AOF日志两种持久化方式，可将内存数据保存到磁盘，方便数据恢复 | 默认不支持持久化，虽可通过第三方工具实现，但不够原生和便捷 | Redis在数据持久化方面更完善，能更好地应对数据丢失风险，保证数据的长期存储 |
| **功能特性** | 具备发布/订阅模式用于消息通信，支持事务（有原子性操作保障），可使用Lua脚本执行自定义复杂逻辑 | 功能相对单一，主要聚焦于缓存功能                           | Redis提供了更多高级功能，可用于构建复杂的分布式应用场景，增强系统的灵活性和可扩展性 |
| **内存管理** | 内存淘汰策略丰富，如LRU（最近最少使用）、LFU（最不经常使用）等多种策略可选 | 内存淘汰策略相对较少                                       | Redis能根据不同业务场景更灵活地管理内存，优化内存使用效率    |
| **集群支持** | 原生支持集群模式（如Redis Cluster），方便进行分布式存储和处理大规模数据 | 虽然也有集群解决方案，但相对复杂且不够原生                 | Redis在集群部署和管理上更简单高效，易于应对高并发和大数据量场景 |

并且，存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis  有部份存在硬盘上，这样能保证数据的持久性。 

## Redis 是单进程单线程的吗

Redis 通常采用单进程单线程模型

### 设计原因
• **简单性**：避免了多线程编程中复杂的锁机制、线程同步和上下文切换开销等问题，降低了开发和维护成本。
 • **避免竞态条件**：由于只有一个线程处理所有命令，不会出现多个线程同时修改数据导致的竞态条件，天然保证了数据的一致性和操作的原子性。

### 优势体现
 • **高性能**：虽然单线程看似会成为性能瓶颈，但实际上 Redis 操作内存的速度极快，单线程可以充分利用 CPU 资源高效处理请求。并且通过高效的事件驱动模型（如 I/O 多路复用），Redis 可以同时处理多个客户端连接，在高并发场景下依然表现出色。
 • **稳定性**：避免了多线程环境下的死锁、资源竞争等复杂问题，使得 Redis 运行更加稳定可靠 。

## 一个字符串类型的值能存储最大容量是多少 

512M

## Redis 的持久化机制是什么？各自的优缺点？

Redis 持久化有 RDB 和 AOF 两种：
• **RDB（快照）**：
    ◦ **原理**：按一定时间间隔将内存数据以快照形式保存到磁盘。
    ◦ **优点**：文件紧凑，适合备份和灾难恢复；恢复速度快。
    ◦ **缺点**：可能会丢失最后一次快照后的数据。
 • **AOF（追加日志）**：
    ◦ **原理**：记录服务器接收到的每个写操作，在服务器启动时会重新执行这些操作来恢复数据。
    ◦ **优点**：数据安全性高，最多丢失一秒的数据；可修改同步策略。
    ◦ **缺点**：AOF 文件体积通常比 RDB 大；恢复速度相对较慢 。

## Redis 常见性能问题和解决方案

1. Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主
线程的工作，当快照比较大时对性能影响是非常大 的，会间断性暂停服务 
2. 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同 步一 （
3. 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局 域网 
4. 尽量避免在压力很大的主库上增加从 
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1<- Slave2 <- Slave3…
这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启
用 Slave1 做 Master，其 他不变。

常见性能问题及解决方案如下：
• **内存不足**：
    ◦ **问题**：数据量过大导致内存耗尽，影响性能甚至崩溃。
    ◦ **方案**：设置合理 maxmemory ，采用数据淘汰策略，如 LRU 等；优化数据结构，减少不必要数据存储。
 • **大 Key 问题**：
    ◦ **问题**：单个 Key 对应的值过大，影响读写性能和内存使用。
    ◦ **方案**：拆分大 Key ，将大对象拆分成多个小 Key-Value 对。
 • **慢查询**：
    ◦ **问题**：某些命令执行时间长，阻塞其他操作。
    ◦ **方案**：优化命令使用，避免复杂命令；使用 SLOWLOG 分析定位慢查询并优化。
 • **网络带宽瓶颈**：
    ◦ **问题**：高并发下网络带宽占用高，导致延迟增加。
    ◦ **方案**：增加带宽；采用集群分摊流量 。

## Redis 过期键的删除策略？


• **惰性删除**：当访问一个已过期的键时，才会删除该键。简单但可能导致过期键长时间占用内存。
• **定期删除**：按一定时间间隔随机抽取部分键检查是否过期并删除。可在一定程度上平衡资源消耗和内存释放。
• **主动删除（结合配置）**：当内存使用达到 maxmemory 且达到一定淘汰策略阈值时，主动清理过期键 。

## Redis 的回收策略（淘汰策略）

Redis 回收策略（淘汰策略）有以下几种：
• **noeviction**：默认策略，内存不足以容纳新写入数据时，新写入操作会报错。
• **allkeys-lru**：移除最近最少使用的 key ，针对所有键。
• **volatile-lru**：在设置了过期时间的键空间中，移除最近最少使用的 key 。
• **allkeys-random**：随机移除某个 key ，针对所有键。
• **volatile-random**：在设置了过期时间的键空间中，随机移除某个 key 。
• **volatile-ttl**：在设置了过期时间的键空间中，优先移除剩余过期时间短的 key 。

##  使用策略规则

### 数据访问模式
• **近期访问频繁的数据更重要**：如果业务数据近期访问过的后续还会频繁访问，适合 `allkeys-lru` 或 `volatile-lru` 。比如热门商品列表缓存，最近被查看的商品后续很可能继续被查看。
 • **数据访问随机**：若数据访问没有明显规律， `allkeys-random` 或 `volatile-random` 较合适。例如缓存一些用户个性化推荐结果，各推荐项访问频率无固定模式。

### 数据过期设置情况
 • **大部分数据有明确过期时间**：优先考虑基于过期时间的策略，如 `volatile-lru`、`volatile-random` 或 `volatile-ttl` 。像缓存用户登录状态，通常会设置过期时间。
 • **较少数据设置过期时间**：若只有少量数据有过期时间， `allkeys-lru` 等针对所有键的策略可能更有效。

### 内存压力和业务容忍度
 • **内存资源紧张**：需要严格控制内存，可选择相对激进策略，如 `volatile-ttl` ，优先淘汰快过期的数据；若对数据丢失较敏感，避免选择可能导致重要数据被淘汰的策略。
 • **能接受一定内存占用**：为保证更多数据可缓存，可选择相对宽松策略，如 `noeviction` （但要注意内存耗尽时的写入报错问题 ）。

## 为什么 Redis 需要把所有数据放到内存中？

Redis 把所有数据放到内存主要有以下原因：
• **高性能读写**：内存读写速度远超磁盘，能实现低延迟的读写操作，满足高并发场景对快速响应的需求。
• **简化数据结构实现**：内存环境便于高效实现和管理 Redis 丰富的数据结构 ，无需处理磁盘复杂的读写逻辑和数据碎片等问题。
• **便于持久化**：基于内存的数据结构进行持久化操作（RDB 快照、AOF 日志）相对简单，利于数据的保存和恢复 。

## Redis 的同步机制了解么？

Redis 同步机制主要涉及主从复制和集群间数据同步：

### 主从复制
• **全量复制**：
    ◦ **过程**：从节点向主节点发送 SYNC 或 PSYNC 命令，主节点收到后执行 BGSAVE 生成 RDB 文件并发送给从节点，同时将 RDB 生成期间的写命令记录在缓冲区。从节点接收并加载 RDB 文件到内存，之后主节点将缓冲区中的写命令发送给从节点执行，完成初始数据同步。
    ◦ **触发场景**：从节点首次连接主节点，或主节点重启等情况。
 • **增量复制**：
    ◦ **过程**：全量复制完成后，主节点后续执行的写命令会实时发送给从节点，保证主从数据持续一致。
    ◦ **触发场景**：主节点正常运行期间进行的写操作。

### 集群间同步
 • **Redis Cluster**：采用哈希槽（hash slot）分配数据到不同节点，节点间通过 Gossip 协议交换集群状态信息。当某个节点数据发生变化，会通过节点间通信将变更传播到其他相关节点 ，确保整个集群数据一致性 。