# Redis

## 什么是 Redis?

Redis 是一个开源的高性能键值对（Key-Value）内存数据库，也被称为数据结构服务器。

### 主要特点
• **速度快**：基于内存操作，读写速度极快，单机能够达到每秒数万次的读写操作。
 • **数据结构丰富**：支持多种数据结构，如字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set） 等，能满足不同场景需求。
 • **持久化**：支持两种持久化方式，RDB（Redis Database）快照和 AOF（Append Only File）日志 ，可将内存中的数据保存到磁盘，方便在服务器重启后恢复数据。
 • **分布式**：可通过集群模式（如 Redis Cluster）实现分布式存储和处理，轻松应对大规模数据和高并发访问。 

### 应用场景
• **缓存**：作为缓存中间件，减轻后端数据库压力，加速数据读取，提升系统整体性能。
 • **消息队列**：利用列表等数据结构实现简单的消息队列功能，用于异步处理和解耦系统组件。 
 • **计数器**：借助 Redis 的原子操作，可方便地实现各种计数器功能，如网站访问量统计、点赞数统计等 。 
 • **分布式锁**：通过SETNX（SET if Not eXists）等命令实现分布式锁，保证在分布式环境下数据的一致性和操作的原子性 。

## Redis 与其他 key-value 存储有什么不同？

| 对比维度         | Redis                                                        | 其他key - value存储（以常见类型为例）                        |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **数据结构**     | 支持丰富数据结构，如字符串、哈希、列表、集合、有序集合等，可对结构执行复杂操作 | 大多仅支持简单键值对，键和值为字节串，操作围绕简单读写       |
| **内存与持久化** | 数据主存内存，读写快；支持RDB快照和AOF日志持久化，可灵活选择或结合 | 部分基于磁盘持久化，内存作缓存加速读写；持久化机制和内存管理策略有别 |
| **功能特性**     | 有发布/订阅模式、事务（简化版）、Lua脚本功能                 | 多数专注基本键值存取，高级特性欠缺                           |
| **性能与扩展性** | 单线程处理高并发出色，通过集群模式（如Redis Cluster）可水平扩展 | 不同实现有差异，有的多线程/进程追求写入性能，扩展方式和复杂操作支持不如Redis |

## 使用 Redis 有哪些好处？

1. 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查 找和操作的时间复杂
度都是 O1) 
2. 支持丰富数据类型，支持 string，list，set，Zset，hash 等 
3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执 行，要么全部不执行 
4. 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除

## Redis 相比 Memcached 有哪些优势？ 

| 对比维度     | Redis                                                        | Memcached                                                  | Redis优势说明                                                |
| ------------ | ------------------------------------------------------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| **数据结构** | 支持丰富的数据结构，如字符串、哈希、列表、集合、有序集合等   | 仅支持简单的键值对存储                                     | Redis能满足更多样化的数据处理需求，可直接对复杂结构进行操作，而Memcached只能进行简单存取 |
| **持久化**   | 支持RDB快照和AOF日志两种持久化方式，可将内存数据保存到磁盘，方便数据恢复 | 默认不支持持久化，虽可通过第三方工具实现，但不够原生和便捷 | Redis在数据持久化方面更完善，能更好地应对数据丢失风险，保证数据的长期存储 |
| **功能特性** | 具备发布/订阅模式用于消息通信，支持事务（有原子性操作保障），可使用Lua脚本执行自定义复杂逻辑 | 功能相对单一，主要聚焦于缓存功能                           | Redis提供了更多高级功能，可用于构建复杂的分布式应用场景，增强系统的灵活性和可扩展性 |
| **内存管理** | 内存淘汰策略丰富，如LRU（最近最少使用）、LFU（最不经常使用）等多种策略可选 | 内存淘汰策略相对较少                                       | Redis能根据不同业务场景更灵活地管理内存，优化内存使用效率    |
| **集群支持** | 原生支持集群模式（如Redis Cluster），方便进行分布式存储和处理大规模数据 | 虽然也有集群解决方案，但相对复杂且不够原生                 | Redis在集群部署和管理上更简单高效，易于应对高并发和大数据量场景 |

并且，存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis  有部份存在硬盘上，这样能保证数据的持久性。 

## Redis 是单进程单线程的吗

Redis 通常采用单进程单线程模型

### 设计原因
• **简单性**：避免了多线程编程中复杂的锁机制、线程同步和上下文切换开销等问题，降低了开发和维护成本。
 • **避免竞态条件**：由于只有一个线程处理所有命令，不会出现多个线程同时修改数据导致的竞态条件，天然保证了数据的一致性和操作的原子性。

### 优势体现
 • **高性能**：虽然单线程看似会成为性能瓶颈，但实际上 Redis 操作内存的速度极快，单线程可以充分利用 CPU 资源高效处理请求。并且通过高效的事件驱动模型（如 I/O 多路复用），Redis 可以同时处理多个客户端连接，在高并发场景下依然表现出色。
 • **稳定性**：避免了多线程环境下的死锁、资源竞争等复杂问题，使得 Redis 运行更加稳定可靠 。

## 一个字符串类型的值能存储最大容量是多少 

512M

## Redis 的持久化机制是什么？各自的优缺点？

Redis 持久化有 RDB 和 AOF 两种：
• **RDB（快照）**：
    ◦ **原理**：按一定时间间隔将内存数据以快照形式保存到磁盘。
    ◦ **优点**：文件紧凑，适合备份和灾难恢复；恢复速度快。
    ◦ **缺点**：可能会丢失最后一次快照后的数据。
 • **AOF（追加日志）**：
    ◦ **原理**：记录服务器接收到的每个写操作，在服务器启动时会重新执行这些操作来恢复数据。
    ◦ **优点**：数据安全性高，最多丢失一秒的数据；可修改同步策略。
    ◦ **缺点**：AOF 文件体积通常比 RDB 大；恢复速度相对较慢 。

## Redis 常见性能问题和解决方案

1. Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主
线程的工作，当快照比较大时对性能影响是非常大 的，会间断性暂停服务 
2. 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同 步一 （
3. 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局 域网 
4. 尽量避免在压力很大的主库上增加从 
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1<- Slave2 <- Slave3…
这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启
用 Slave1 做 Master，其 他不变。

常见性能问题及解决方案如下：
• **内存不足**：
    ◦ **问题**：数据量过大导致内存耗尽，影响性能甚至崩溃。
    ◦ **方案**：设置合理 maxmemory ，采用数据淘汰策略，如 LRU 等；优化数据结构，减少不必要数据存储。
 • **大 Key 问题**：
    ◦ **问题**：单个 Key 对应的值过大，影响读写性能和内存使用。
    ◦ **方案**：拆分大 Key ，将大对象拆分成多个小 Key-Value 对。
 • **慢查询**：
    ◦ **问题**：某些命令执行时间长，阻塞其他操作。
    ◦ **方案**：优化命令使用，避免复杂命令；使用 SLOWLOG 分析定位慢查询并优化。
 • **网络带宽瓶颈**：
    ◦ **问题**：高并发下网络带宽占用高，导致延迟增加。
    ◦ **方案**：增加带宽；采用集群分摊流量 。

## Redis 过期键的删除策略？


• **惰性删除**：当访问一个已过期的键时，才会删除该键。简单但可能导致过期键长时间占用内存。
• **定期删除**：按一定时间间隔随机抽取部分键检查是否过期并删除。可在一定程度上平衡资源消耗和内存释放。
• **主动删除（结合配置）**：当内存使用达到 maxmemory 且达到一定淘汰策略阈值时，主动清理过期键 。

## Redis 的回收策略（淘汰策略）

Redis 回收策略（淘汰策略）有以下几种：
• **noeviction**：默认策略，内存不足以容纳新写入数据时，新写入操作会报错。
• **allkeys-lru**：移除最近最少使用的 key ，针对所有键。
• **volatile-lru**：在设置了过期时间的键空间中，移除最近最少使用的 key 。
• **allkeys-random**：随机移除某个 key ，针对所有键。
• **volatile-random**：在设置了过期时间的键空间中，随机移除某个 key 。
• **volatile-ttl**：在设置了过期时间的键空间中，优先移除剩余过期时间短的 key 。

##  使用策略规则

### 数据访问模式
• **近期访问频繁的数据更重要**：如果业务数据近期访问过的后续还会频繁访问，适合 `allkeys-lru` 或 `volatile-lru` 。比如热门商品列表缓存，最近被查看的商品后续很可能继续被查看。
 • **数据访问随机**：若数据访问没有明显规律， `allkeys-random` 或 `volatile-random` 较合适。例如缓存一些用户个性化推荐结果，各推荐项访问频率无固定模式。

### 数据过期设置情况
 • **大部分数据有明确过期时间**：优先考虑基于过期时间的策略，如 `volatile-lru`、`volatile-random` 或 `volatile-ttl` 。像缓存用户登录状态，通常会设置过期时间。
 • **较少数据设置过期时间**：若只有少量数据有过期时间， `allkeys-lru` 等针对所有键的策略可能更有效。

### 内存压力和业务容忍度
 • **内存资源紧张**：需要严格控制内存，可选择相对激进策略，如 `volatile-ttl` ，优先淘汰快过期的数据；若对数据丢失较敏感，避免选择可能导致重要数据被淘汰的策略。
 • **能接受一定内存占用**：为保证更多数据可缓存，可选择相对宽松策略，如 `noeviction` （但要注意内存耗尽时的写入报错问题 ）。

## 为什么 Redis 需要把所有数据放到内存中？

Redis 把所有数据放到内存主要有以下原因：
• **高性能读写**：内存读写速度远超磁盘，能实现低延迟的读写操作，满足高并发场景对快速响应的需求。
• **简化数据结构实现**：内存环境便于高效实现和管理 Redis 丰富的数据结构 ，无需处理磁盘复杂的读写逻辑和数据碎片等问题。
• **便于持久化**：基于内存的数据结构进行持久化操作（RDB 快照、AOF 日志）相对简单，利于数据的保存和恢复 。

## Redis 的同步机制了解么？

Redis 同步机制主要涉及主从复制和集群间数据同步：

### 主从复制
• **全量复制**：
    ◦ **过程**：从节点向主节点发送 SYNC 或 PSYNC 命令，主节点收到后执行 BGSAVE 生成 RDB 文件并发送给从节点，同时将 RDB 生成期间的写命令记录在缓冲区。从节点接收并加载 RDB 文件到内存，之后主节点将缓冲区中的写命令发送给从节点执行，完成初始数据同步。
    ◦ **触发场景**：从节点首次连接主节点，或主节点重启等情况。
 • **增量复制**：
    ◦ **过程**：全量复制完成后，主节点后续执行的写命令会实时发送给从节点，保证主从数据持续一致。
    ◦ **触发场景**：主节点正常运行期间进行的写操作。

### 集群间同步
 • **Redis Cluster**：采用哈希槽（hash slot）分配数据到不同节点，节点间通过 Gossip 协议交换集群状态信息。当某个节点数据发生变化，会通过节点间通信将变更传播到其他相关节点 ，确保整个集群数据一致性 。

## Pipeline 有什么好处，为什么要用 Pipeline？

可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之 间没 有因果相关性。使用 Redis
benchmark 进行压测的时候可以发现影响 Redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数
目。 

## 是否使用过 Redis 集群，集群的原理是什么？

1. Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升 为 master，继续提供服务。 
2. Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。 

## Redis 如何设置密码及验证密码？

设置密码：config set requirepass 123456 
授权密码：auth 123456

## 说说 Redis 哈希槽的概念？ 

Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群 有 16384 个哈希槽，每个 key 
通过 CRC16 校验后对 16384 取模来决定放置 哪 个槽，集群的每个节点负责一部分 hash 槽。 
## Redis 集群的主从复制模型是怎样的？  
为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用， 所以 集群使用了主从复制模型,
每个节点都会有 N-1 个复制品。
## Redis 集群会有写操作丢失吗？为什么？  
Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件 下可 能会丢失写操作。 
## Redis 集群之间是如何复制的？  
异步复制 
## Redis 集群最大节点个数是多少？  
16384 个。 
## Redis 集群如何选择数据库？  
Redis 集群目前无法做数据库选择，默认在 0 数据库

## 怎么测试 Redis 的连通性  
使用 ping 命令。
## 怎么理解 Redis 事务？  

1. 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执 行。事务在执行的过程
中，不会被其他客户端发送来的命令请求所打断。 
2. 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执 行。
Redis 事务相关的命令有哪几个？ 
MULTI、EXEC、DISCARD、WATCH 
Redis key 的过期时间和永久有效分别怎么设置？ 
EXPIRE 和 PERSIST 命令。

## Redis 回收进程如何工作的？ 
一个客户端运行了新的命令，添加了新的数据。Redi 检查内存使用情况， 如 果大于 maxmemory 的限
制, 则根据设定好的策略进行回收。一个新的命令被 执 行，等等。所以我们不断地穿越内存限制的边
界，通过不断达到边界然后不 断 地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如
很大 的 集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超 越。

## Redis 的内存用完了会发生什么？ 
如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可 以正 常返回。）或者你可以将 
Redis 当缓存来使用配置淘汰机制，当 Redis 达到 内存上限时会冲刷掉旧的内容。

## MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如 何保证 Redis 中的数据都是热点数据？
Redis 内存数据集大小上升 到一定大小的时候，就会施行数据淘汰策略。 相关知识：Redis 提供 6 种数
据淘汰策略： 
volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选 最近最少使用的数据淘汰 
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选 将要过期的数据淘汰 
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任 意选择数据淘汰 
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘 汰 
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 
no-enviction（驱逐）：禁止驱逐数据

## Redis 最适合的场景？

1. **缓存**：将频繁访问的数据存储在内存中，减少对数据库的直接访问，提高系统性能。
2. **消息队列**：用于实现任务队列、发布/订阅模式，支持异步处理。
3. **排行榜和计数器**：快速更新和查询数据，如网站的实时排行榜、用户访问次数统计。
4. **会话存储**：存储用户会话信息，支持快速读取和更新。
5. **分布式锁**：用于分布式系统中的锁机制，保证资源访问的互斥性。
6. **数据备份和持久化**：支持数据的持久化存储，可作为数据库的备份或辅助存储。

## 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来？ 
使用 keys 指令可以扫出指定模式的 key 列表。 对方接着追问：如果这个 Redis 正在给线上的业务提供
服务，那使用 keys 指 令会有什么问题？ 这个时候你要回答 Redis 关键的一个特性：Redis 的单线程
的。keys 指令会 导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢 复。这个时
候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 70 key 列表，但是会有一定的重复概
率，在客户端做一次去重就可以了，但是整 体所花费的时间会比直接用 keys 指令长。
## 如果有大量的 key 需要设置同一时间过期，一般需要注意什 么？ 
如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis 可能 会出现短暂的卡顿现象。
一般需要在时间上加一个随机值，使得过期时间 分散 一些。
## 使用过 Redis 做异步队列么，你是怎么用的？ 
一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没 有消息的时候，要适当 sleep 
一会再重试。 
如果对方追问可不可以不 用 sleep 呢？ 
list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直 到消息到来。
如果对方追问能不能生产一次消费多次呢？ 
使用 pub/sub 主题订 阅者模式，可以实现 1:N 的消息队列。 
如果对方追问 pub/sub 有什么缺点？ 
在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ 等。 
如果对方追问 Redis 如何实现延时队列？ 
使用 sortedset，拿时间 戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 
zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。

## 介绍一下redis分布式锁，怎么使用

Redis分布式锁是一种在分布式系统中用于协调多个进程或线程对共享资源访问的机制。它通过Redis的原子操作来实现，确保在多个节点之间对资源的互斥访问。以下是关于Redis分布式锁的介绍和使用方法。

### 一、Redis分布式锁的原理
Redis分布式锁的核心思想是利用Redis的`SET`命令的原子性。`SET`命令支持一个`NX`选项，表示只有当键不存在时才设置值。通过这种方式，可以确保只有一个客户端能够获取锁。

例如，使用`SET resource_name lock_value NX PX 30000`命令，其中：
- `resource_name`是锁的名称（键）。
- `lock_value`是锁的值，通常是一个随机生成的唯一标识符。
- `NX`表示只有当键不存在时才设置值。
- `PX`表示设置键的过期时间，单位为毫秒（这里是30秒）。

如果命令执行成功，返回`OK`，表示获取锁成功；如果返回`nil`，表示锁已被其他客户端占用。

### 二、Redis分布式锁的使用步骤
以下是使用Redis分布式锁的典型步骤：

#### 1. 尝试获取锁
客户端尝试通过`SET`命令获取锁：
```bash
SET resource_name lock_value NX PX 30000
```
- 如果返回`OK`，表示获取锁成功，可以执行后续操作。
- 如果返回`nil`，表示锁已被占用，需要等待或重试。

#### 2. 执行业务逻辑
获取锁成功后，客户端可以安全地执行需要互斥访问的业务逻辑。

#### 3. 释放锁
业务逻辑执行完成后，需要释放锁。释放锁时，需要确保只有锁的持有者才能释放锁，避免误释放其他客户端的锁。通常通过Lua脚本实现：
```lua
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```
- `KEYS[1]`是锁的名称（`resource_name`）。
- `ARGV[1]`是锁的值（`lock_value`）。
- 如果锁的值匹配，删除锁；否则，不做任何操作。

在Redis客户端中，可以这样调用Lua脚本：
```bash
EVAL "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end" 1 resource_name lock_value
```

### 三、注意事项
1. **锁的过期时间**：设置合理的过期时间，避免客户端崩溃导致锁无法释放。
2. **重试机制**：如果获取锁失败，可以设置重试逻辑，如等待一段时间后再次尝试。
3. **锁的值**：锁的值应是一个唯一标识符，如UUID，以避免不同客户端之间的锁值冲突。
4. **线程安全**：在多线程环境中，确保获取锁和释放锁的操作是线程安全的。

