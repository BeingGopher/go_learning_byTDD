# 八股积累

## 内存逃逸

Go 的内存逃逸是指在 Go 语言中，本应分配在栈上的变量，由于某些原因被分配到了堆上。以下是关于 Go 内存逃逸的详细介绍：

### 栈与堆的区别

- **栈**：
  - 分配和回收速度快，由编译器自动管理。
  - 变量生命周期与函数绑定，函数结束后自动回收。
  - 适合存储局部变量和小型数据。
- **堆**：
  - 分配和回收速度较慢，需要垃圾回收器（GC）管理。
  - 变量生命周期不固定。
  - 适合存储大型数据或需要跨函数共享的数据。

### 内存逃逸的原因

- **返回局部变量的指针**：如果函数返回一个局部变量的指针，该局部变量会被分配到堆上。例如：

  go复制

  ```go
  func foo() *int {
      x := 42
      return &x
  }
  ```

  在这种情况下，`x` 会被分配到堆上，因为函数返回后它仍然需要存在。

- **闭包捕获外部变量**：如果闭包函数捕获了外部函数的局部变量，这些变量可能会被分配到堆上。例如：

  go复制

  ```go
  func bar() func() {
      y := 42
      return func() {
          fmt.Println(y)
      }
  }
  ```

  在这种情况下，`y` 会被分配到堆上，因为闭包函数可能在 `bar` 函数返回后被调用。

- **接口和切片分配**：接口和切片的底层数据结构可能会导致内存逃逸。例如，将局部变量作为接口参数传递，可能会导致该变量被分配到堆上。

- **大对象分配**：对于大型的数据结构，Go 有时会选择在堆上分配内存，即使它们没有在函数外部被引用。

- **切片和 map 操作**：如果对切片进行操作可能导致其重新分配内存，或者向 map 中插入数据，这些操作可能导致逃逸。

### 内存逃逸的影响

- **性能开销**：堆上的变量需要通过 GC 回收，增加了额外的性能开销。
- **延迟增加**：GC 的执行可能会导致程序暂停（STW），增加延迟。

### 逃逸分析

Go 编译器会在编译阶段对变量生命周期进行分析，决定变量分配在堆还是栈。可以通过以下命令查看哪些变量发生了内存逃逸：

```bash
go build -gcflags '-m' main.go
```

### 优化建议

- **减少不必要的指针传递**：避免使用指针返回局部变量，改为直接返回值。
- **减少动态分配**：使用固定大小的数组或切片，避免频繁扩容。
- **优化接口使用**：尽量使用具体类型，减少接口动态分配。

## case细节

```go
type student struct {
 	Name string
}
func zhoujielun(v interface{}) {
 	switch msg := v.(type) {
 		case *student, student:
 			msg.Name
 	}
}
```

golang中有规定， switch type 的 case T1 ，类型列表只有⼀个，那么 v := m.(type) 中的 v 的类型就是 T1类型。  

如果是 case T1, T2 ，类型列表中有多个，那 v 的类型还是多对应接⼝的类型，也就 是 m 的类型。  所以这⾥ msg 的类型还是 interface{} ，所以他没有 Name 这个字段，编译阶段就会报错。

## json

按照 golang 的语法，⼩写开头的⽅法、属性或  struct 是私有的，同样，在 json 解 码或转码的时候也⽆ 法上线私有属性的转换。 题⽬中是⽆法正常得到 People 的 name 值的。⽽且，私有属性 name 也不应 该加 json 的标签。  

## 原子操作

原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行 的过程中，CPU绝不会再去进行其他的针对该值的操作。

为了实现这样的严谨 性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过 CPU 指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作。

## 原子操作和锁的区别

原子操作由底层硬件支持，而锁则由操作系统的调度器实现。 锁应当用来保护一段逻辑，对于一个变量更新的保护。 原子操作通常执行上会更有效率，并且更能利用计算机多核的优势，如果要更新的是一个 复合对象，则应当使用 atomic.Value 封装好的实现  

| **特性**     | **原子操作**             | **锁**                   |
| ------------ | ------------------------ | ------------------------ |
| **实现**     | 硬件指令（如 CAS）       | 操作系统原语或用户态锁   |
| **性能**     | 更轻量，适合简单操作     | 代价较高，适合复杂操作   |
| **适用场景** | 单一变量更新、高性能场景 | 复杂临界区、读多写少场景 |
| **复杂性**   | 简单                     | 较复杂                   |

## CAS 

CAS 的全称为 Compare And Swap，直译就是比较交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令， 在 intel 的CPU中，使用的cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提升效率。

## sync.Pool

对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给  GC 带来一定的负担，严重的时候会引起 CPU 的毛 刺。而 sync.Pool 可以将暂时将不用的对象缓存起 来，待下次需要的时候直 接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。 

- **并发安全**：`sync.Pool` 是并发安全的，多个 goroutine 可以安全地从中获取和放回对象。
- **自动清理**：`sync.Pool` 中的对象可能会被垃圾回收器自动清理（GC 时会清空池中的对象）。
- **无大小限制**：`sync.Pool` 不会限制池中对象的数量，但 GC 会定期清理未使用的对象。

### 1. **使用场景**

- 频繁创建和销毁对象的场景（如字符串、切片、结构体等）。
- 高并发场景下需要减少内存分配和 GC 压力。
- 临时对象的复用（如网络连接、缓冲区等）。

### 2. **核心方法**

- **`Get()`**：从池中获取一个对象。如果池为空，则调用 `New` 函数创建一个新对象。
- **`Put(x)`**：将对象放回池中，以便后续复用。

## GMP

G（Goroutine）：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息。 

M（Machine）：对内核级线程的封装，数量对应真实的CPU数（真正干活的对象）。  

P（Processor）：即为G和M的调度对象，用来调度G和M之间的关联关系， 其数量可通过GOMAXPROCS()来设置，默认为核心数。

## GMP中的work stealing机制

获取 P 本地队列，当从绑定 P 本地 runq 上找不到可执行的 g，尝试从全局链表中拿，再拿不到从 netpoll 和事件池里拿，最后会从别的 P 里偷任务。P 此时去唤醒一个 M。P 继续执行其它的程序。M寻找是否有空闲的 P，如果有则 将该 G 对象移动到它本身。接下来 M 执行一个调度循环（调用 G 对象-> 执行-> 清理线程→继续找新的 Goroutine 执行）  

## 基于信号的抢占式调度

在任何情况下，Go 运行时并行执行（注意，不是并发）的 goroutines 数量是 小于等于 P 的数量的。为 了提高系统的性能，P 的数量肯定不是越小越好，所以官方默认值就是 CPU 的核心数，设置的过小的话，如果一个持有 P 的 M， 由于 P 当前执行的 G 调用了 syscall 而导致 M 被阻塞，那么此时关键点：  GO 的调度器是迟钝的，它很可能什么都没做，直到 M 阻塞了相当长时间以 后，才会发现有一个 P/M 被  syscall 阻塞了。然后，才会用空闲的 M 来抢这 个 P。通过 sysmon 监控实现的抢占式调度，最快在  20us，最慢在 10-20ms 才 会发现有一个 M 持有 P 并阻塞了。操作系统在 1ms 内可以完成很多次线程 调 度（一般情况 1ms 可以完成几十次线程调度），Go 发起 IO/syscall 的时候执 行该 G 的 M 会阻塞然 后被 OS 调度走，P 什么也不干，sysmon 最慢要 10-20ms 才能发现这个阻塞，说不定那时候阻塞已经 结束了，这样宝贵的 P 资源就这么 被阻塞的 M 浪费了。

## GC 触发时机

主动触发：调用 runtime.GC 。

被动触发： 使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分 钟。当超过 两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如Go的GC是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例。

## GC流程

### 1. **GC 的触发条件**

GC 会在以下情况下触发：

- **堆内存达到阈值**：Go的GC会根据堆内存的增长情况动态调整触发阈值。
- **手动触发**：通过调用 `runtime.GC()` 强制触发 GC。
- **定时触发**：Go 的 GC 会根据运行时的状态定期触发。

### 2. **GC 的阶段**

Go 的 GC 分为四个主要阶段：

#### **阶段 1: STW（Stop The World） - 准备阶段**

- 暂停所有 goroutine（Stop The World），确保程序状态的一致性。
- 初始化 GC 相关的数据结构，例如标记队列、位图等。
- 启动写屏障（Write Barrier），用于在并发标记阶段捕捉指针的修改。

#### **阶段 2: 并发标记（Concurrent Marking）**

- **标记根对象**：从根对象（如全局变量、栈、寄存器等）开始，标记所有可达的对象。
- **并发标记**：在程序运行的同时，遍历对象图，标记所有存活的对象。这一阶段与用户程序并发执行。
- **写屏障**：在标记过程中，如果用户程序修改了指针，写屏障会捕捉这些修改，确保不会漏掉新创建的对象。

#### **阶段 3: STW - 标记终止阶段**

- 再次暂停所有 goroutine，完成剩余的标记工作。
- 扫描栈和全局变量，确保所有存活对象都被标记。
- 关闭写屏障。

#### **阶段 4: 并发清除（Concurrent Sweeping）**

- 回收未被标记的对象（即不可达对象），释放它们占用的内存。
- 将释放的内存归还给堆，以便后续分配。
- 这一阶段与用户程序并发执行。

### 3. **GC 的优化**

Go 的 GC 在设计和实现上做了许多优化，以减少对程序性能的影响：

- **并发执行**：标记和清除阶段与用户程序并发执行，减少 STW 的时间。
- **写屏障**：通过写屏障捕捉指针的修改，确保并发标记的正确性。
- **三色标记法**：使用三色（黑、灰、白）标记法高效地遍历对象图。
- **动态调整阈值**：根据堆内存的增长情况动态调整 GC 触发阈值，避免频繁 GC。

### 4. **GC 的性能影响**

尽管 Go 的 GC 已经做了很多优化，但它仍然会对程序性能产生一定的影响：

- **STW 暂停**：虽然 Go 的 STW 时间很短，但在高负载场景下仍可能导致延迟。
- **CPU 开销**：并发标记和清除会占用一定的 CPU 资源。
- **内存开销**：GC 需要额外的内存来维护标记信息和写屏障。

### 5. **如何减少 GC 的影响**

- **减少内存分配**：尽量复用对象，使用 `sync.Pool` 缓存临时对象。
- **避免内存泄漏**：确保不再使用的对象能被 GC 回收。
- **优化数据结构**：使用更高效的数据结构，减少内存占用。

### 6. **GC 的监控和调试**

Go 提供了多种工具和 API 来监控和调试 GC：

- **`GODEBUG` 环境变量**：通过设置 `GODEBUG=gctrace=1` 可以实时输出 GC 的日志。
- **`runtime.ReadMemStats`**：获取内存和 GC 的统计信息。
- **pprof 工具**：分析程序的堆内存和 GC 性能。

## 微服务

微服务，又称微服务架构，是一种架构风格，它将应用程序构建为以业务领域为模型的小型自治服务集合。

## 微服务架构的优势

1. 独立开发 所有微服务都可以根据各自的功能轻松开发  
2. 独立部署 根据他们所提供的服务，可以在任何应用中单独部署  
3. 故障隔离 即使应用中的一个服务不起作用，系统仍然继续运行  
4. 混合技术栈 可以用不同的语言和技术来构建同一应用程序的不同服务 

5. 粒度缩放 各个组件可根据需要进行扩展，无需将所有组件融合到一起  

## 微服务特点

1.解耦—系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展  

2.组件化—微服务被视为可以轻松更换和升级的独立组件  

3.业务能力—微服务非常简单，专注于单一功能  

4.自治—开发人员和团队可以彼此独立工作，从而提高速度  

5.持续交付—通过软件创建，测试和批准的系统自动化，允许频繁发布软件  

6.责任—微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品  

7.分散治理—重点是使用正确的工具来做正确的工作。这意味着没有标准化 模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题

8.敏捷—微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃

## 微服务架构如何运作 

1. 客户端 – 来自不同设备的不同用户发送请求。 
2. 身份提供商 – 验证用户或客户身份并颁发安全令牌。 
3. API网关 – 处理客户端请求。 
4. 静态内容 – 容纳系统的所有内容。 
5. 管理 – 在节点上平衡服务并识别故障。 
6. 服务发现 – 查找微服务之间通信路径的指南。 
7. 网络 – 代理服务器及其数据中心的分布式网络。 
8. 远程服务 – 启用驻留在 IT 设备网络上的远程访问信息

## 微服务架构的缺点

1. 复杂性高
微服务将系统拆分为多个独立服务，导致系统复杂度和运维复杂度大幅增加。
2. 分布式系统的挑战
服务间通信引入网络延迟、性能开销和数据一致性问题，调试和排查故障更加困难。
3. 开发与运维成本高
需要更多的开发资源、运维工具和团队协作，增加了整体成本。
4. 测试与部署难度大
集成测试和端到端测试复杂，独立部署需要解决依赖管理和版本兼容性问题。
5. 不适合所有场景
小型项目或简单应用可能因微服务引入不必要的复杂性，而低延迟需求场景可能受通信开销影响。

## 单片，SOA 和微服务架构有什么区别

1. 单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密 封装。 
2. 一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数据传递，也可以涉及两个
或多个协调某些活动的服务。
3. 微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。

## 领域驱动设计

### 1. **核心概念**

- **领域**：软件涉及的业务范围。
- **限界上下文**：领域模型的边界，每个上下文有自己的规则和术语。
- **实体**：有唯一标识的对象（如用户）。
- **值对象**：无唯一标识的对象（如地址）。
- **聚合**：一组相关对象，由聚合根管理。
- **仓储**：管理聚合的持久化和检索。
- **领域事件**：记录领域中发生的重要事情。

### 2. **分层架构**

- **用户界面层**：与用户交互。
- **应用层**：协调领域逻辑和基础设施。
- **领域层**：核心业务逻辑和模型。
- **基础设施层**：技术实现（如数据库）。

### 3. **设计与实践**

- **战术设计**：实现领域模型（实体、值对象、聚合等）。
- **战略设计**：划分限界上下文，明确上下文关系。
- **上下文映射**：描述上下文之间的协作方式（如共享内核、防腐层）。

### 4. **优势**

- **业务与代码一致**：模型反映业务需求。
- **可维护性高**：系统更易于扩展和维护。
- **灵活性高**：支持复杂业务场景。

### 5. **挑战**

- **学习曲线陡峭**：概念较多，需时间掌握。
- **适合复杂系统**：简单系统可能过度设计。
- **依赖领域专家**：需与业务专家紧密合作。

### 6. **适用场景**

- 复杂业务系统（如电商、金融）。
- 需要定制化领域逻辑。
- 长期演进的大型系统。

## 什么是 REST / RESTful 以及它的用途是什么

**RESTful API** 是一种基于 REST（Representational State Transfer）架构风格设计的 Web 服务接口。以下是精简版总结：

### 1. **核心原则**

- **无状态**：每次请求包含所有必要信息，服务器不保存客户端状态。
- **统一接口**：使用标准的 HTTP 方法（GET、POST、PUT、DELETE）和状态码。
- **资源导向**：将数据抽象为资源，通过URI访问。
- **可缓存**：支持缓存以提高性能。
- **分层系统**：客户端和服务器之间可以存在中间层（如代理、网关）。

### 2. **HTTP 方法**

- **GET**：获取资源。
- **POST**：创建资源。
- **PUT**：更新资源。
- **DELETE**：删除资源。
- **PATCH**：部分更新资源。

### 3. **状态码**

- **2xx**：成功（如 200 OK，201 Created）。
- **3xx**：重定向（如 301 Moved Permanently）。
- **4xx**：客户端错误（如 400 Bad Request，404 Not Found）。
- **5xx**：服务器错误（如 500 Internal Server Error）。

### 4. **URI 设计**

- 使用名词表示资源，如 `/users`。
- 使用复数形式，如 `/users` 而不是 `/user`。
- 避免动词，如 `/getUsers` 不符合 RESTful风格。

### 5. **请求与响应**

- **请求**：包含方法、URI、头信息和主体（如 JSON、XML）。
- **响应**：包含状态码、头信息和主体（如 JSON、XML）。

### 6. **版本控制**

- 在 URI 中体现版本，如 `/v1/users`。
- 使用头信息（如 `Accept`）指定版本。

### 7. **认证与授权**

- 使用 **OAuth2** 或 **JWT** 进行身份验证和授权。
- 在头信息中传递 Token，如 `Authorization: Bearer <token>`。

### 8. **分页与过滤**

- 使用查询参数实现分页，如 `/users?page=1&limit=10`。
- 使用查询参数实现过滤，如 `/users?status=active`。

## 不同类型的微服务测试

1. 在底层，我们有面向技术的测试，如单元测试和性能测试。这些是完全自 动化的。 
2. 在中间层面，我们进行了诸如压力测试和可用性测试之类的探索性测试。 
3. 在顶层， 我们的验收测试数量很少。这些验收测试有助于利益相关者理解 和验证软件功能  

## DevOps  

1. 核心目标
快速交付：缩短开发到部署的时间。
高质量：减少错误，提高稳定性。
团队协作：打破开发与运维的壁垒。
2. 为什么需要 DevOps？
解决对立：开发追求快速交付，运维追求稳定，DevOps 平衡两者。
自动化：减少手动操作，提高效率。
快速反馈：及早发现问题，降低修复成本。
3. 核心实践
持续集成（CI）：频繁合并代码，自动测试。
持续交付（CD）：自动化部署，随时发布。
基础设施即代码（IaC）：用代码管理基础设施。
监控与日志：实时监控，集中管理日志。
4. DevOps 工具
代码管理：Git、GitHub。
CI/CD：Jenkins、GitLab CI。
容器化：Docker、Kubernetes。
监控：Prometheus、Grafana。
5. 优势
加速交付：更快发布新功能。
提高质量：减少错误，增强稳定性。
降低成本：减少手动操作和故障修复。
6. 挑战
文化转变：需要团队改变传统工作方式。
技能要求：学习和掌握新工具。
工具整合：选择合适的工具链。

## Docker

Docker 是一个容器化平台，它包装你所有开发环境依赖成一个整体，像一个容 器。保证项目开发，如开发、测试、发布等各生产环节都可以无缝工作在不同的平台 

Docker容器：将一个软件包装在一个完整的文件系统中，该文件系统包含运行所需的一切：代码，运行时，系统工具，系统库等。可以安装在 服务器上的任 何东西。 这保证软件总是运行在相同的运行环境，无需考虑基础环境配置的改变。

## CI 服务有什么用途

CI （Continuous Integration）-- 持续集成服务 -- 主要用于整合团队开发 中不同开发者提交到开发仓库 中的项目代码变化，并即时整合编译，检查整合编译错误的服务。它需要一天中多次整合编译代码的能 力，若出现整合错误， 可以优异地准确定位提交错误源 

## 如何使用 Docker 技术创建与环境无关的容器系统？

Docker 技术有三中主要的技术途径辅助完成此需求：  

存储卷（Volumes）  

环境变量（Environment variable）注入  

只读（Read-only）文件系统 

## Dockerfile 配置文件中的 COPY 和 ADD 指令有什么不 同？

虽然 ADD 和 COPY 功能相似，推荐 COPY那是因为 COPY 比 ADD 更直观易懂。 

COPY 只是将本地文件拷入容器这么简 单，而 ADD 有一些其它 特性功能（诸如，本地归档解压和支持远程网址访问 等），这些特性在指令本身体现并不明显。因此， 有必要使用 ADD 指令的最好例子是需要在本地自动解压归档文件到容器中的情况，如 ADD  rootfs.tar.xz 。  

## Docker 镜像（image）是什么

Docker image 是Docker容器的源。换言之，Docker images 用于创建 Docker 容器（containers）。 映像（Images）通过 Docker build 命令创建，当 run 映像时，它启动成一个 容器（container）进程。 做好的映像由于可 能非常庞大，常注册存储在诸如 registry.hub.docker.com 这样的公共平台 上。 映像常被分层设计，每层可单独成为一个小映像，由多层小映像再构成大 映像，这样碎片化的设计为了 使映像在互联网上共享时，最小化传输数据需 求。

## Docker 容器（container）是什么

Docker containers -- Docker 容器 -- 是包含其所有运行依赖环境，但与其它容器共享操作系统内核的应用，它运行在独立的主机操作系统用户空间进程 中。Docker容器并不紧密依赖特定的基础平台：可运行在任何配置的计算机， 任何平台以及任何云平台上

## Docker 容器运行阶段

运行中（Running） 已暂停（Paused） 重启中（Restarting） 已退出（Exited） 

## 有什么方法确定一个 Docker 容器运行状态

使用如下命令行命令确定一个 Docker 容器的运行状态  

```bash
docker ps –a
```

这将列表形式输出运行在主机上的所有 Docker 容器及其运行状态。从这个列 表中很容易找到想要的容 器及其运行状态。

## 在 Dockerfile 配置文件中最常用的指令有哪些

1. FROM：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile 中， FROM 是第一条
指令。
2. LABEL：LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。
在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。 
3. RUN：RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中 添加功能层，也
许最来的层会依赖它。 
4. CMD：使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个CMD指令，
只有最后的 CMD 指令运行 