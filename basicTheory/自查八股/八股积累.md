# 八股积累

## 内存逃逸

Go 的内存逃逸是指在 Go 语言中，本应分配在栈上的变量，由于某些原因被分配到了堆上。以下是关于 Go 内存逃逸的详细介绍：

### 栈与堆的区别

- **栈**：
  - 分配和回收速度快，由编译器自动管理。
  - 变量生命周期与函数绑定，函数结束后自动回收。
  - 适合存储局部变量和小型数据。
- **堆**：
  - 分配和回收速度较慢，需要垃圾回收器（GC）管理。
  - 变量生命周期不固定。
  - 适合存储大型数据或需要跨函数共享的数据。

### 内存逃逸的原因

- **返回局部变量的指针**：如果函数返回一个局部变量的指针，该局部变量会被分配到堆上。例如：

  go复制

  ```go
  func foo() *int {
      x := 42
      return &x
  }
  ```

  在这种情况下，`x` 会被分配到堆上，因为函数返回后它仍然需要存在。

- **闭包捕获外部变量**：如果闭包函数捕获了外部函数的局部变量，这些变量可能会被分配到堆上。例如：

  go复制

  ```go
  func bar() func() {
      y := 42
      return func() {
          fmt.Println(y)
      }
  }
  ```

  在这种情况下，`y` 会被分配到堆上，因为闭包函数可能在 `bar` 函数返回后被调用。

- **接口和切片分配**：接口和切片的底层数据结构可能会导致内存逃逸。例如，将局部变量作为接口参数传递，可能会导致该变量被分配到堆上。

- **大对象分配**：对于大型的数据结构，Go 有时会选择在堆上分配内存，即使它们没有在函数外部被引用。

- **切片和 map 操作**：如果对切片进行操作可能导致其重新分配内存，或者向 map 中插入数据，这些操作可能导致逃逸。

### 内存逃逸的影响

- **性能开销**：堆上的变量需要通过 GC 回收，增加了额外的性能开销。
- **延迟增加**：GC 的执行可能会导致程序暂停（STW），增加延迟。

### 逃逸分析

Go 编译器会在编译阶段对变量生命周期进行分析，决定变量分配在堆还是栈。可以通过以下命令查看哪些变量发生了内存逃逸：

```bash
go build -gcflags '-m' main.go
```

### 优化建议

- **减少不必要的指针传递**：避免使用指针返回局部变量，改为直接返回值。
- **减少动态分配**：使用固定大小的数组或切片，避免频繁扩容。
- **优化接口使用**：尽量使用具体类型，减少接口动态分配。

## case细节

```go
type student struct {
 	Name string
}
func zhoujielun(v interface{}) {
 	switch msg := v.(type) {
 		case *student, student:
 			msg.Name
 	}
}
```

golang中有规定， switch type 的 case T1 ，类型列表只有⼀个，那么 v := m.(type) 中的 v 的类型就是 T1类型。  

如果是 case T1, T2 ，类型列表中有多个，那 v 的类型还是多对应接⼝的类型，也就 是 m 的类型。  所以这⾥ msg 的类型还是 interface{} ，所以他没有 Name 这个字段，编译阶段就会报错。

## json

按照 golang 的语法，⼩写开头的⽅法、属性或  struct 是私有的，同样，在 json 解 码或转码的时候也⽆ 法上线私有属性的转换。 题⽬中是⽆法正常得到 People 的 name 值的。⽽且，私有属性 name 也不应 该加 json 的标签。  

## 原子操作

原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行 的过程中，CPU绝不会再去进行其他的针对该值的操作。

为了实现这样的严谨 性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过 CPU 指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作。

## 原子操作和锁的区别

原子操作由底层硬件支持，而锁则由操作系统的调度器实现。 锁应当用来保护一段逻辑，对于一个变量更新的保护。 原子操作通常执行上会更有效率，并且更能利用计算机多核的优势，如果要更新的是一个 复合对象，则应当使用 atomic.Value 封装好的实现  

| **特性**     | **原子操作**             | **锁**                   |
| ------------ | ------------------------ | ------------------------ |
| **实现**     | 硬件指令（如 CAS）       | 操作系统原语或用户态锁   |
| **性能**     | 更轻量，适合简单操作     | 代价较高，适合复杂操作   |
| **适用场景** | 单一变量更新、高性能场景 | 复杂临界区、读多写少场景 |
| **复杂性**   | 简单                     | 较复杂                   |

## CAS 

CAS 的全称为 Compare And Swap，直译就是比较交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令， 在 intel 的CPU中，使用的cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提升效率。

## sync.Pool

对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给  GC 带来一定的负担，严重的时候会引起 CPU 的毛 刺。而 sync.Pool 可以将暂时将不用的对象缓存起 来，待下次需要的时候直 接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。 

- **并发安全**：`sync.Pool` 是并发安全的，多个 goroutine 可以安全地从中获取和放回对象。
- **自动清理**：`sync.Pool` 中的对象可能会被垃圾回收器自动清理（GC 时会清空池中的对象）。
- **无大小限制**：`sync.Pool` 不会限制池中对象的数量，但 GC 会定期清理未使用的对象。

### 1. **使用场景**

- 频繁创建和销毁对象的场景（如字符串、切片、结构体等）。
- 高并发场景下需要减少内存分配和 GC 压力。
- 临时对象的复用（如网络连接、缓冲区等）。

### 2. **核心方法**

- **`Get()`**：从池中获取一个对象。如果池为空，则调用 `New` 函数创建一个新对象。
- **`Put(x)`**：将对象放回池中，以便后续复用。

## GMP

G（Goroutine）：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息。 

M（Machine）：对内核级线程的封装，数量对应真实的CPU数（真正干活的对象）。  

P（Processor）：即为G和M的调度对象，用来调度G和M之间的关联关系， 其数量可通过GOMAXPROCS()来设置，默认为核心数。

## GMP中的work stealing机制

获取 P 本地队列，当从绑定 P 本地 runq 上找不到可执行的 g，尝试从全局链表中拿，再拿不到从 netpoll 和事件池里拿，最后会从别的 P 里偷任务。P 此时去唤醒一个 M。P 继续执行其它的程序。M寻找是否有空闲的 P，如果有则 将该 G 对象移动到它本身。接下来 M 执行一个调度循环（调用 G 对象-> 执行-> 清理线程→继续找新的 Goroutine 执行）  

## 基于信号的抢占式调度

在任何情况下，Go 运行时并行执行（注意，不是并发）的 goroutines 数量是 小于等于 P 的数量的。为 了提高系统的性能，P 的数量肯定不是越小越好，所以官方默认值就是 CPU 的核心数，设置的过小的话，如果一个持有 P 的 M， 由于 P 当前执行的 G 调用了 syscall 而导致 M 被阻塞，那么此时关键点：  GO 的调度器是迟钝的，它很可能什么都没做，直到 M 阻塞了相当长时间以 后，才会发现有一个 P/M 被  syscall 阻塞了。然后，才会用空闲的 M 来抢这 个 P。通过 sysmon 监控实现的抢占式调度，最快在  20us，最慢在 10-20ms 才 会发现有一个 M 持有 P 并阻塞了。操作系统在 1ms 内可以完成很多次线程 调 度（一般情况 1ms 可以完成几十次线程调度），Go 发起 IO/syscall 的时候执 行该 G 的 M 会阻塞然 后被 OS 调度走，P 什么也不干，sysmon 最慢要 10-20ms 才能发现这个阻塞，说不定那时候阻塞已经 结束了，这样宝贵的 P 资源就这么 被阻塞的 M 浪费了。

## GC 触发时机

主动触发：调用 runtime.GC 。

被动触发： 使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分 钟。当超过 两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如Go的GC是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例。

## GC流程

### 1. **GC 的触发条件**

GC 会在以下情况下触发：

- **堆内存达到阈值**：Go的GC会根据堆内存的增长情况动态调整触发阈值。
- **手动触发**：通过调用 `runtime.GC()` 强制触发 GC。
- **定时触发**：Go 的 GC 会根据运行时的状态定期触发。

### 2. **GC 的阶段**

Go 的 GC 分为四个主要阶段：

#### **阶段 1: STW（Stop The World） - 准备阶段**

- 暂停所有 goroutine（Stop The World），确保程序状态的一致性。
- 初始化 GC 相关的数据结构，例如标记队列、位图等。
- 启动写屏障（Write Barrier），用于在并发标记阶段捕捉指针的修改。

#### **阶段 2: 并发标记（Concurrent Marking）**

- **标记根对象**：从根对象（如全局变量、栈、寄存器等）开始，标记所有可达的对象。
- **并发标记**：在程序运行的同时，遍历对象图，标记所有存活的对象。这一阶段与用户程序并发执行。
- **写屏障**：在标记过程中，如果用户程序修改了指针，写屏障会捕捉这些修改，确保不会漏掉新创建的对象。

#### **阶段 3: STW - 标记终止阶段**

- 再次暂停所有 goroutine，完成剩余的标记工作。
- 扫描栈和全局变量，确保所有存活对象都被标记。
- 关闭写屏障。

#### **阶段 4: 并发清除（Concurrent Sweeping）**

- 回收未被标记的对象（即不可达对象），释放它们占用的内存。
- 将释放的内存归还给堆，以便后续分配。
- 这一阶段与用户程序并发执行。

### 3. **GC 的优化**

Go 的 GC 在设计和实现上做了许多优化，以减少对程序性能的影响：

- **并发执行**：标记和清除阶段与用户程序并发执行，减少 STW 的时间。
- **写屏障**：通过写屏障捕捉指针的修改，确保并发标记的正确性。
- **三色标记法**：使用三色（黑、灰、白）标记法高效地遍历对象图。
- **动态调整阈值**：根据堆内存的增长情况动态调整 GC 触发阈值，避免频繁 GC。

### 4. **GC 的性能影响**

尽管 Go 的 GC 已经做了很多优化，但它仍然会对程序性能产生一定的影响：

- **STW 暂停**：虽然 Go 的 STW 时间很短，但在高负载场景下仍可能导致延迟。
- **CPU 开销**：并发标记和清除会占用一定的 CPU 资源。
- **内存开销**：GC 需要额外的内存来维护标记信息和写屏障。

### 5. **如何减少 GC 的影响**

- **减少内存分配**：尽量复用对象，使用 `sync.Pool` 缓存临时对象。
- **避免内存泄漏**：确保不再使用的对象能被 GC 回收。
- **优化数据结构**：使用更高效的数据结构，减少内存占用。

### 6. **GC 的监控和调试**

Go 提供了多种工具和 API 来监控和调试 GC：

- **`GODEBUG` 环境变量**：通过设置 `GODEBUG=gctrace=1` 可以实时输出 GC 的日志。
- **`runtime.ReadMemStats`**：获取内存和 GC 的统计信息。
- **pprof 工具**：分析程序的堆内存和 GC 性能。

## 微服务

微服务，又称微服务架构，是一种架构风格，它将应用程序构建为以业务领域为模型的小型自治服务集合。

## 微服务架构的优势

1. 独立开发 所有微服务都可以根据各自的功能轻松开发  
2. 独立部署 根据他们所提供的服务，可以在任何应用中单独部署  
3. 故障隔离 即使应用中的一个服务不起作用，系统仍然继续运行  
4. 混合技术栈 可以用不同的语言和技术来构建同一应用程序的不同服务 

5. 粒度缩放 各个组件可根据需要进行扩展，无需将所有组件融合到一起  

## 微服务特点

1.解耦—系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展  

2.组件化—微服务被视为可以轻松更换和升级的独立组件  

3.业务能力—微服务非常简单，专注于单一功能  

4.自治—开发人员和团队可以彼此独立工作，从而提高速度  

5.持续交付—通过软件创建，测试和批准的系统自动化，允许频繁发布软件  

6.责任—微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品  

7.分散治理—重点是使用正确的工具来做正确的工作。这意味着没有标准化 模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题

8.敏捷—微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃

## 微服务架构如何运作 

1. 客户端 – 来自不同设备的不同用户发送请求。 
2. 身份提供商 – 验证用户或客户身份并颁发安全令牌。 
3. API网关 – 处理客户端请求。 
4. 静态内容 – 容纳系统的所有内容。 
5. 管理 – 在节点上平衡服务并识别故障。 
6. 服务发现 – 查找微服务之间通信路径的指南。 
7. 网络 – 代理服务器及其数据中心的分布式网络。 
8. 远程服务 – 启用驻留在 IT 设备网络上的远程访问信息

## 微服务架构的缺点

1. 复杂性高
微服务将系统拆分为多个独立服务，导致系统复杂度和运维复杂度大幅增加。
2. 分布式系统的挑战
服务间通信引入网络延迟、性能开销和数据一致性问题，调试和排查故障更加困难。
3. 开发与运维成本高
需要更多的开发资源、运维工具和团队协作，增加了整体成本。
4. 测试与部署难度大
集成测试和端到端测试复杂，独立部署需要解决依赖管理和版本兼容性问题。
5. 不适合所有场景
小型项目或简单应用可能因微服务引入不必要的复杂性，而低延迟需求场景可能受通信开销影响。

## 单片，SOA 和微服务架构有什么区别

1. 单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密 封装。 
2. 一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数据传递，也可以涉及两个
或多个协调某些活动的服务。
3. 微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。

## 领域驱动设计

### 1. **核心概念**

- **领域**：软件涉及的业务范围。
- **限界上下文**：领域模型的边界，每个上下文有自己的规则和术语。
- **实体**：有唯一标识的对象（如用户）。
- **值对象**：无唯一标识的对象（如地址）。
- **聚合**：一组相关对象，由聚合根管理。
- **仓储**：管理聚合的持久化和检索。
- **领域事件**：记录领域中发生的重要事情。

### 2. **分层架构**

- **用户界面层**：与用户交互。
- **应用层**：协调领域逻辑和基础设施。
- **领域层**：核心业务逻辑和模型。
- **基础设施层**：技术实现（如数据库）。

### 3. **设计与实践**

- **战术设计**：实现领域模型（实体、值对象、聚合等）。
- **战略设计**：划分限界上下文，明确上下文关系。
- **上下文映射**：描述上下文之间的协作方式（如共享内核、防腐层）。

### 4. **优势**

- **业务与代码一致**：模型反映业务需求。
- **可维护性高**：系统更易于扩展和维护。
- **灵活性高**：支持复杂业务场景。

### 5. **挑战**

- **学习曲线陡峭**：概念较多，需时间掌握。
- **适合复杂系统**：简单系统可能过度设计。
- **依赖领域专家**：需与业务专家紧密合作。

### 6. **适用场景**

- 复杂业务系统（如电商、金融）。
- 需要定制化领域逻辑。
- 长期演进的大型系统。

## 什么是 REST / RESTful 以及它的用途是什么

**RESTful API** 是一种基于 REST（Representational State Transfer）架构风格设计的 Web 服务接口。以下是精简版总结：

### 1. **核心原则**

- **无状态**：每次请求包含所有必要信息，服务器不保存客户端状态。
- **统一接口**：使用标准的 HTTP 方法（GET、POST、PUT、DELETE）和状态码。
- **资源导向**：将数据抽象为资源，通过URI访问。
- **可缓存**：支持缓存以提高性能。
- **分层系统**：客户端和服务器之间可以存在中间层（如代理、网关）。

### 2. **HTTP 方法**

- **GET**：获取资源。
- **POST**：创建资源。
- **PUT**：更新资源。
- **DELETE**：删除资源。
- **PATCH**：部分更新资源。

### 3. **状态码**

- **2xx**：成功（如 200 OK，201 Created）。
- **3xx**：重定向（如 301 Moved Permanently）。
- **4xx**：客户端错误（如 400 Bad Request，404 Not Found）。
- **5xx**：服务器错误（如 500 Internal Server Error）。

### 4. **URI 设计**

- 使用名词表示资源，如 `/users`。
- 使用复数形式，如 `/users` 而不是 `/user`。
- 避免动词，如 `/getUsers` 不符合 RESTful风格。

### 5. **请求与响应**

- **请求**：包含方法、URI、头信息和主体（如 JSON、XML）。
- **响应**：包含状态码、头信息和主体（如 JSON、XML）。

### 6. **版本控制**

- 在 URI 中体现版本，如 `/v1/users`。
- 使用头信息（如 `Accept`）指定版本。

### 7. **认证与授权**

- 使用 **OAuth2** 或 **JWT** 进行身份验证和授权。
- 在头信息中传递 Token，如 `Authorization: Bearer <token>`。

### 8. **分页与过滤**

- 使用查询参数实现分页，如 `/users?page=1&limit=10`。
- 使用查询参数实现过滤，如 `/users?status=active`。

## 不同类型的微服务测试

1. 在底层，我们有面向技术的测试，如单元测试和性能测试。这些是完全自 动化的。 
2. 在中间层面，我们进行了诸如压力测试和可用性测试之类的探索性测试。 
3. 在顶层， 我们的验收测试数量很少。这些验收测试有助于利益相关者理解 和验证软件功能  

## DevOps  

1. 核心目标
快速交付：缩短开发到部署的时间。
高质量：减少错误，提高稳定性。
团队协作：打破开发与运维的壁垒。
2. 为什么需要 DevOps？
解决对立：开发追求快速交付，运维追求稳定，DevOps 平衡两者。
自动化：减少手动操作，提高效率。
快速反馈：及早发现问题，降低修复成本。
3. 核心实践
持续集成（CI）：频繁合并代码，自动测试。
持续交付（CD）：自动化部署，随时发布。
基础设施即代码（IaC）：用代码管理基础设施。
监控与日志：实时监控，集中管理日志。
4. DevOps 工具
代码管理：Git、GitHub。
CI/CD：Jenkins、GitLab CI。
容器化：Docker、Kubernetes。
监控：Prometheus、Grafana。
5. 优势
加速交付：更快发布新功能。
提高质量：减少错误，增强稳定性。
降低成本：减少手动操作和故障修复。
6. 挑战
文化转变：需要团队改变传统工作方式。
技能要求：学习和掌握新工具。
工具整合：选择合适的工具链。

## Docker

Docker 是一个容器化平台，它包装你所有开发环境依赖成一个整体，像一个容 器。保证项目开发，如开发、测试、发布等各生产环节都可以无缝工作在不同的平台 

Docker容器：将一个软件包装在一个完整的文件系统中，该文件系统包含运行所需的一切：代码，运行时，系统工具，系统库等。可以安装在 服务器上的任 何东西。 这保证软件总是运行在相同的运行环境，无需考虑基础环境配置的改变。

## CI 服务有什么用途

CI （Continuous Integration）-- 持续集成服务 -- 主要用于整合团队开发 中不同开发者提交到开发仓库 中的项目代码变化，并即时整合编译，检查整合编译错误的服务。它需要一天中多次整合编译代码的能 力，若出现整合错误， 可以优异地准确定位提交错误源 

## 如何使用 Docker 技术创建与环境无关的容器系统？

Docker 技术有三中主要的技术途径辅助完成此需求：  

存储卷（Volumes）  

环境变量（Environment variable）注入  

只读（Read-only）文件系统 

## Dockerfile 配置文件中的 COPY 和 ADD 指令有什么不 同？

虽然 ADD 和 COPY 功能相似，推荐 COPY那是因为 COPY 比 ADD 更直观易懂。 

COPY 只是将本地文件拷入容器这么简 单，而 ADD 有一些其它 特性功能（诸如，本地归档解压和支持远程网址访问 等），这些特性在指令本身体现并不明显。因此， 有必要使用 ADD 指令的最好例子是需要在本地自动解压归档文件到容器中的情况，如 ADD  rootfs.tar.xz 。  

## Docker 镜像（image）是什么

Docker image 是Docker容器的源。换言之，Docker images 用于创建 Docker 容器（containers）。 映像（Images）通过 Docker build 命令创建，当 run 映像时，它启动成一个 容器（container）进程。 做好的映像由于可 能非常庞大，常注册存储在诸如 registry.hub.docker.com 这样的公共平台 上。 映像常被分层设计，每层可单独成为一个小映像，由多层小映像再构成大 映像，这样碎片化的设计为了 使映像在互联网上共享时，最小化传输数据需 求。

## Docker 容器（container）是什么

Docker containers -- Docker 容器 -- 是包含其所有运行依赖环境，但与其它容器共享操作系统内核的应用，它运行在独立的主机操作系统用户空间进程 中。Docker容器并不紧密依赖特定的基础平台：可运行在任何配置的计算机， 任何平台以及任何云平台上

## Docker 容器运行阶段

运行中（Running） 已暂停（Paused） 重启中（Restarting） 已退出（Exited） 

## 有什么方法确定一个 Docker 容器运行状态

使用如下命令行命令确定一个 Docker 容器的运行状态  

```bash
docker ps –a
```

这将列表形式输出运行在主机上的所有 Docker 容器及其运行状态。从这个列 表中很容易找到想要的容 器及其运行状态。

## 在 Dockerfile 配置文件中最常用的指令有哪些

1. FROM：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile 中， FROM 是第一条
指令。
2. LABEL：LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。
在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。 
3. RUN：RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中 添加功能层，也
许最来的层会依赖它。 
4. CMD：使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个CMD指令，
只有最后的 CMD 指令运行 

## 什么类型的应用（无状态性或有状态性）更适合 Docker 容器技术

对于 Docker 容器创建无状态性（Stateless）的应用更可取。通过从应用项目中将与状态相关的信息及
配置提取掉，我们可以在项目环境外建立不依赖项目环境的Docker容器。这样，我们可以在任意产品
中运行同一容器，只需根据产品需要像问 & 答（QA）一样给其配置环境即可。 这帮助我们在不同场景
重用相同的 Docker 映像。另外，使用无状态性（Stateless）容器应用相比有 状态性（Stateful）容器
应用更具伸缩性，也容易创建。

因为容器可快速创建、销毁和迁移，无状态应用不依赖特定存储或会话状态，便于在不同容器间切换，利于水平扩展和资源高效利用 。

## 解释基本 Docker 应用流程 

1. **编写 Dockerfile**：定义镜像构建步骤，如基础镜像、安装软件、复制文件等。
2. **构建镜像**：用 `docker build` 命令根据 Dockerfile 构建镜像。
3. **运行容器**：用 `docker run` 命令基于镜像启动容器。
4. **管理容器**：可使用命令如 `docker stop` 停止、`docker start` 启动、`docker rm` 删除容器等 。

## Docker Image 和 Docker Layer（层) 有什么不同？

Docker Image 是静态的只读模板，用于创建容器；Docker Layer 是镜像构建时各步骤产生的可复用对象，多个层叠加组成一个镜像 。

## 虚拟化技术是什么？

虚拟化技术是一种资源管理技术，通过抽象和隔离硬件资源，在物理硬件之上创建多个相互隔离的虚拟环境（如虚拟机、容器等），让每个虚拟环境能独立运行操作系统和应用程序，提高资源利用率 。

## 虚拟管理层（程序）是什么 

虚拟管理层（程序）负责管理和调度虚拟化资源。它运行在物理硬件和虚拟机（或容器等虚拟环境）之间，对底层硬件资源进行抽象、分配、监控等操作 ，保障各虚拟环境稳定高效运行 。如**VMware vSphere**、**Hyper - V管理器**

## Docker 集群（Swarm）是什么 

Docker Swarm是Docker原生的集群管理和编排工具。它可将多个Docker主机组成一个单一的虚拟Docker主机，实现资源池化 。能进行容器的分布式部署、负载均衡、滚动更新等操作 ，方便管理大规模容器集群 。类似于k8s

## 在使用 Docker 技术的产品中如何监控其运行

Docker 在产品中提供如运行统计和 Docker 事件的工具。可以通过这些工具命令获取 Docker 运行状
况的统计信息或报告。 

Docker stats ： 通过指定的容器 id 获取其运行统计信息，可获得容器对 CPU，内存使用情况等的统计信息，类似 Linux 系统中的top命令。

Docker events ：Docker事件是一个命令，用于观察显示运行中的 Docker一系列的行为活动。

 一般的 Docker 事件有：attach（关联），commit（提交），die（僵死）， detach（取消关联），rename（改名），destroy（销毁）等。也可使用多个选 项对事件记录筛选找到想要的事件信息 。

## 什么是孤儿卷及如何删除它

孤儿卷是未与任何容器关联的卷。
docker volume rm 删除指定的卷
docker volume prune 删除所有孤儿卷

## 什么是半虚拟化（Paravirtualization）

半虚拟化是一种虚拟化技术。它通过修改客户机操作系统内核，使其知道自己运行在虚拟环境中，从而与虚拟化层（如Hypervisor）协同工作，减少模拟硬件带来的性能开销 ，提升虚拟机性能 。

## Docker 技术与虚拟机技术有何不同？

Docker技术与虚拟机技术在多方面存在不同：

### 架构层面

- **虚拟机**：基于Hypervisor（如VMware ESXi、Hyper - V等）实现，Hypervisor直接运行在物理硬件之上，为每个虚拟机模拟出一套完整的硬件环境，每个虚拟机都包含自己的操作系统内核 ，多个虚拟机相互隔离且独立运行。
- **Docker**：基于容器技术，容器运行在宿主机的操作系统之上，共享宿主机的内核。多个容器可以共用宿主机的操作系统内核资源，通过命名空间和控制组等技术实现资源隔离和管理。

### 资源占用

- **虚拟机**：由于需要为每个实例配备完整的操作系统，会占用较多的系统资源，包括内存、CPU等。启动虚拟机也需要相对较长的时间，因为要加载完整的操作系统。
- **Docker**：容器共享宿主机内核，只包含应用程序及其依赖的库和文件，资源占用极少。启动速度快，通常能在秒级完成启动，能快速创建和销毁大量实例。

### 隔离性

- **虚拟机**：提供了很强的隔离性，每个虚拟机都有独立的操作系统和硬件资源模拟，在一个虚拟机出现问题时，基本不会影响到其他虚拟机 。不过这种隔离性也带来了一定的开销。
- **Docker**：容器之间通过命名空间和控制组实现隔离，但隔离性相对虚拟机较弱。如果宿主机内核出现问题，可能会影响到所有容器。不过在正常情况下，容器间的隔离能满足大多数应用场景需求。

### 部署和管理

- **虚拟机**：部署相对复杂，需要安装和配置操作系统、驱动等。管理上涉及对多个虚拟机的操作系统进行维护、更新等操作。
- **Docker**：部署简单，通过编写Dockerfile定义镜像构建规则，可快速创建标准化镜像并部署容器。管理方面，借助Docker Compose、Kubernetes等工具，能方便地进行容器的编排和管理。

### 应用场景

- **虚拟机**：适合运行需要完整操作系统环境的应用，如一些对硬件兼容性要求较高、需要特定操作系统版本支持的传统企业级应用。
- **Docker**：更适合微服务架构、快速迭代的开发和测试环境，以及需要快速扩展和弹性伸缩的场景，如互联网应用的后端服务 。

## 请解释一下 docker file 配置文件中的 ONBUILD 指令的用途含义

`ONBUILD` 指令用于在当前镜像作为基础镜像构建其他镜像时，添加额外的构建步骤 。当一个包含 `ONBUILD` 指令的镜像被用作另一个 Dockerfile 的 `FROM` 指令的基础镜像时，`ONBUILD` 后面的指令会在新镜像构建过程中执行 。例如：

```Dockerfile
FROM ubuntu
ONBUILD RUN echo "This command runs when this image is used as a base image"
```

上述示例中，当此镜像被其他 Dockerfile 作为基础镜像时，会执行 `echo` 命令 。常用于创建通用基础镜像，在其上构建的具体镜像可根据需求自动执行特定配置或安装操作 。

## 是否在创建有状态性的 Docker 应用的有较好实践？ 最适合的场景有什么 

有状态性Docker应用创建的好实践：

- 持久化存储：使用Docker卷或绑定挂载来保存数据，如数据库文件。
- 稳定的网络标识：为容器分配固定的网络名称或标签以便其他服务定位。

最适合场景：

- 数据库应用：像MySQL、PostgreSQL等需要存储数据且有状态的服务。
- 消息队列：如RabbitMQ等需要保存消息状态的应用。
- 有配置文件且需持久化的应用：配置文件需保存且与应用状态相关的情况 。

## 容器化技术在底层的运行原理

容器化技术底层主要基于操作系统层面的隔离机制：

- **命名空间（Namespaces）**：实现资源隔离，如PID（进程ID）、NET（网络）、MNT（挂载点）、UTS（主机名和域名）等命名空间，让容器有独立的资源视图。
- **控制组（Cgroups）**：用于限制、控制和统计容器的资源使用（CPU、内存、磁盘I/O等） 。

## 说说容器化技术与虚拟化技术的优缺点 

### 容器化技术

- 

  优点

  - **轻量级**：共享宿主机内核，启动快，占用资源少。
  - **高效部署**：镜像可快速分发，便于大规模部署。
  - **环境一致性好**：开发、测试、生产环境易保持一致。

- 

  缺点

  - **隔离性相对弱**：依赖宿主机内核，安全性稍逊。
  - **不适合多内核需求**：无法像虚拟机那样运行不同内核系统。

### 虚拟化技术

- 

  优点

  - **隔离性强**：每个虚拟机有独立内核，安全性高。
  - **兼容性好**：能运行不同操作系统和内核版本。

- 

  缺点

  - **资源开销大**：需额外虚拟硬件资源，较重。
  - **启动慢**：相比容器启动时间长 。

## 如何使 Docker 适应多种运行环境 

- **使用环境变量**：在 Dockerfile 或运行命令中定义环境变量，根据不同环境赋值。
- **构建多阶段镜像**：分离构建和运行阶段，适配不同环境需求。
- **编写灵活配置文件**：让应用读取配置文件获取环境相关参数。
- **利用 Docker Compose 或编排工具**：针对不同环境定义不同的服务编排文件 。

## 为什么 Docker compose 采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略？

- **性能考虑**：减少整体启动时间，避免串行等待带来的延迟。
- **实际场景适配**：有些服务启动后能快速响应，少量未就绪情况可被应用自身逻辑处理 。

## 什么是k8s？说出你的理解

K8s是kubernetes的简称，其本质是一个开源的容器编排系统，主要用于管理容器化的应用，其目标是
让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种
机制。
说简单点：k8s就是一个编排容器的系统，一个可以管理容器应用全生命周期的工具，从创建应用，应用
的部署，应用提供服务，扩容缩容应用，应用更新，都非常的方便，而且还可以做到故障自愈，所以，
k8s是一个非常强大的容器编排系统。

## k8s的组件有哪些，作用分别是什么

- **API Server**：提供K8s各类资源操作的RESTful API接口，是集群的前端控制平面组件。
- **etcd**：分布式键值存储，保存K8s集群所有重要数据，如配置信息、状态等。
- **Controller Manager**：运行各种控制器，确保集群资源处于期望状态，如节点控制器、副本控制器等。
- **Scheduler**：负责将Pod调度到合适的节点上运行，根据资源情况等因素做决策。
- **kubelet**：运行在每个节点上，负责管理该节点上的容器，确保Pod按要求运行。
- **kube - proxy**：运行在每个节点，实现服务的网络代理和负载均衡，使外部能访问集群内服务 。

## kubelet的功能、作用是什么？

- 管理节点上的Pod生命周期，包括创建、启动、停止和销毁Pod等操作。
- 监控节点资源使用情况，如CPU、内存等，并向Kubernetes API Server汇报。
- 与容器运行时交互（如Docker等），执行容器的操作命令。
- 执行节点健康检查，确保节点处于正常状态以便可靠地运行Pod 。

## kube-api-server的端口是多少？各个pod是如何访问 kube-api-server的？

**一、kube - api - server默认端口**

- kube - api - server默认监听两个端口：
  - 8080端口（用于本地通信，在集群内部组件间通信时可能用到，这个端口在较新版本中可能默认关闭或者不推荐用于生产环境外部访问）。
  - 6443端口（这是安全的HTTPS端口，主要用于集群外部组件与kube - api - server通信以及集群内部重要组件间的安全通信）。

**二、Pod访问kube - api - server的方式**

- 通过Service代理
  - 在Kubernetes集群中，kube - api - server通常会有一个对应的Service（一般名为kube - apiserver）。Pod可以通过这个Service来访问kube - api - server。Service会将请求转发到后端的kube - api - server实例上。例如，在同一个命名空间下，Pod可以使用`kube - apiserver.default.svc.cluster.local:6443`（假设在default命名空间）这样的地址来访问kube - api - server。
- 环境变量配置
  - 集群初始化时，kubelet等组件会设置一些环境变量（如`KUBERNETES_SERVICE_HOST`和`KUBERNETES_SERVICE_PORT`），Pod内的应用程序可以利用这些环境变量构建访问kube - api - server的地址。例如，在Go语言编写的应用中，可以通过读取这些环境变量来构建HTTP请求的URL，从而访问kube-api-server。

## k8s中命名空间的作用是什么

- **资源隔离**：不同命名空间中的资源（如Pod、Service等）相互隔离，避免命名冲突。
- **权限管理**：可针对不同命名空间设置不同的访问权限，方便多租户场景下的安全管理。
- **资源管理**：便于对资源进行分组管理，如按项目、部门等划分命名空间来分别管理资源配额等 。

## k8s提供了大量的REST接口，其中有一个是Kubernetes  Proxy API接口，简述一下这个Proxy接口的作用，已经怎 么使用

**一、Kubernetes Proxy API接口作用**

- **反向代理**：为集群内部的服务提供反向代理功能，使得外部客户端可以通过kube - proxy访问集群内不同节点上的服务。
- **负载均衡**：在多个后端Pod之间进行负载均衡，将客户端请求均匀分发到对应的Pod上。

**二、使用方式**

- 通过kubectl proxy命令启动本地代理：
  - 在本地机器上执行`kubectl proxy`命令，默认会在本地的8001端口启动一个代理服务。
  - 然后就可以通过类似`http://localhost:8001/api/v1/nodes`这样的URL访问Kubernetes API ，其中`/api/v1/nodes`是API的具体路径。
- 直接访问kube - proxy服务（在集群内）：
  - 在集群内部的Pod中，可以通过集群内的Service来访问kube - proxy 。例如，如果kube - proxy以ClusterIP类型的Service暴露，Pod可以通过该Service的ClusterIP和相应端口来使用Proxy API 。

## pod是什么

- Pod是Kubernetes中最小的可部署、可管理的计算单元。
- 一个Pod可以包含一个或多个紧密相关的容器，这些容器共享网络命名空间、存储卷等资源 。

## pod的原理是什么

- **共享网络**：Pod内容器共享一个网络命名空间，有相同的IP和端口空间，可通过`localhost`互相通信。
- **共享存储**：可通过挂载存储卷（Volumes）实现数据共享，多个容器能访问相同数据。
- **封装容器**：将相关容器组合在一起，便于管理和调度，作为一个整体进行部署、扩展等操作 。

## pod有什么特点

- **原子性**：作为一个整体被调度和管理，要么全部运行，要么全部失败。
- **资源共享**：Pod内容器共享网络和存储资源，方便通信和数据交互。
- **轻量级**：相比虚拟机更轻量，启动速度快，资源开销小 。

## pause容器作用是什么

1. 网络命名空间共享基础
   - 为Pod中的其他容器提供共享的网络命名空间。在Kubernetes中，一个Pod内的多个容器共享同一个网络命名空间，Pause容器率先创建并初始化这个网络命名空间，其他容器加入其中，从而实现容器间网络通信等功能，比如它们可以通过localhost互相访问。
2. 进程管理辅助
   - 可以作为Pod内其他容器的父容器，在一定程度上协助进行进程管理。例如，当Pod需要被停止时，Pause容器的停止可以作为整个Pod停止过程的一部分，有助于确保Pod内所有容器的有序停止 。

## pod的重启策略有哪些

1. **Always（总是重启）**：无论容器因何原因退出，Kubernetes 都会尝试重启容器。
2. **OnFailure（失败时重启）**：仅当容器以非零状态码退出时，才会重启容器。
3. **Never（从不重启）**：无论容器退出状态如何，Kubernetes 都不会重启容器 。

## pod的镜像拉取策略有哪几种

1. **Always（总是拉取）**：每次启动容器时都会尝试拉取最新镜像。
2. **IfNotPresent（若不存在则拉取）**：本地有镜像就使用本地镜像，没有则从仓库拉取。
3. **Never（从不拉取）**：只使用本地镜像，不尝试从仓库拉取 。

## pod的存活探针有哪几种？

1. **Exec**：在容器内执行指定命令，根据命令的退出状态码判断容器是否存活，状态码为 0 表示健康。
2. **TCPSocket**：尝试与容器内的指定端口建立 TCP 连接，连接成功则认为容器存活。
3. **HTTPGet**：向容器内的指定 IP 地址、端口和路径发送 HTTP 请求，根据响应状态码判断，通常 2xx 或 3xx 状态码视为存活 。

## 存活探针的属性参数有哪几个？

1. **initialDelaySeconds**：容器启动后等待多少秒后开始执行第一次探测，默认值为 0 秒。
2. **periodSeconds**：执行探测的时间间隔（单位：秒），默认值是 10 秒。
3. **timeoutSeconds**：探测超时时间（单位：秒），默认值是 1 秒。
4. **successThreshold**：探测失败后，最少连续探测成功多少次才被认定为成功，默认值对于存活探针是 1 ，最小值是 1。
5. **failureThreshold**：探测成功后，最少连续探测失败多少次才被认定为失败，默认值是 3 。

## pod的就绪探针有哪几种？

Pod 的就绪探针（Readiness Probe）和存活探针类型相同，主要有以下三种：

1. **Exec**：在容器内执行指定命令，依据命令退出状态码判断，状态码为 0 表示就绪。
2. **TCPSocket**：尝试连接容器内指定端口，连接成功意味着容器已就绪。
3. **HTTPGet**：向容器内特定 IP、端口和路径发送 HTTP 请求，响应状态码为 2xx 或 3xx 通常表示就绪 。

## 就绪探针的属性参数有哪些

就绪探针（Readiness Probe）属性参数和存活探针基本一致，主要有以下几个：

1. **initialDelaySeconds**：容器启动后延迟多少秒开始进行第一次就绪探测，默认是 0 秒 。
2. **periodSeconds**：两次就绪探测之间的时间间隔，单位为秒，默认值 10 秒。
3. **timeoutSeconds**：单次就绪探测的超时时间，单位为秒，默认值 1 秒。
4. **successThreshold**：探测失败后，连续成功多少次才认为就绪，默认值 1（对于就绪探针一般保持默认即可）。
5. **failureThreshold**：探测成功后，连续失败多少次才认为就绪失败，默认值 3 。

## 就绪探针与存活探针区别是什么

就绪探针（Readiness Probe）与存活探针（Liveness Probe）主要有以下区别：

### 目的不同

- **存活探针**：主要目的是判断容器是否还处于健康运行状态。如果存活探针检测失败，Kubernetes 会根据重启策略决定是否重启容器，以确保应用持续可用。
- **就绪探针**：用于确定容器是否已经准备好接收流量。当一个 Pod 中的所有容器都通过了就绪探针检测，Kubernetes 才会将 Pod 纳入服务的负载均衡池中，开始对外提供服务。

### 失败影响不同

- 存活探针：
  - 对于 `Always` 和 `OnFailure` 重启策略，如果存活探针持续失败，容器会被重启（`Always` 策略下总是重启，`OnFailure` 策略下在失败时重启）。
  - 对于 `Never` 策略则不会重启容器，但 Pod 处于不健康状态。
- **就绪探针**：就绪探针失败时，不会触发容器的重启操作。只是将该 Pod 从服务的 Endpoints 列表中移除，不再接收新的请求 ，直到就绪探针再次成功 。

## 简单讲一下 pod创建过程

1. **用户提交请求**：通过 kubectl 或 API 提交 Pod 定义（YAML/JSON 格式）给 Kubernetes API Server。
2. **API Server 处理**：验证请求合法性，存储 Pod 信息到 etcd 存储系统 。
3. **调度器介入**：Scheduler 从 etcd 获取 Pod 信息，根据资源需求、节点状态等为 Pod 选择合适节点。
4. **节点准备**：选定的节点上的 kubelet 收到调度信息后，拉取 Pod 配置。
5. **镜像拉取**：kubelet 根据 Pod 中定义的镜像拉取策略，从镜像仓库拉取所需镜像到本地节点。
6. **容器创建与启动**：kubelet 使用容器运行时（如 Docker）在节点上创建并启动 Pod 内的各个容器。
7. **状态上报**：kubelet 持续监控 Pod 状态，并将状态更新反馈给 API Server 。

## 简单描述一下pod的终止过程

1. **删除信号发出**：用户通过 `kubectl delete pod` 等操作，API Server 接收删除 Pod 的请求，并将删除标记添加到 Pod 对象上。
2. 优雅终止：
   - **发送 SIGTERM 信号**：kubelet 收到删除指令后，向 Pod 内的每个容器发送 SIGTERM 信号，通知容器准备终止。此时容器有机会进行一些清理工作，如关闭连接、保存状态等。
   - **等待 preStop 钩子执行（如果有）**：如果容器定义了 preStop 钩子，在发送 SIGTERM 信号后会执行该钩子，完成一些自定义的终止前操作。
3. **终止宽限期**：Kubernetes 启动一个终止宽限期（默认 30 秒，可通过 `terminationGracePeriodSeconds` 字段配置）。
4. **发送 SIGKILL 信号**：如果在宽限期内容器仍未自行终止，kubelet 会向容器发送 SIGKILL 信号强制终止容器。
5. **资源清理**：容器终止后，kubelet 会清理与该容器相关的资源，如网络命名空间等。最终，Pod 对象也会从 API Server 的 etcd 存储中被删除 。

## pod的生命周期有哪几种

1. **Pending（挂起）**：Pod 已被 Kubernetes 系统接受，但尚未调度到节点上，或者正在等待镜像拉取等操作完成。
2. **Running（运行中）**：Pod 已经成功调度到某个节点，并且所有容器都已创建，至少有一个容器正在运行。
3. **Succeeded（成功）**：Pod 内的所有容器都已成功终止，并且不会再重启（例如，批处理任务完成）。
4. **Failed（失败）**：Pod 内至少有一个容器以非零状态码退出，并且不会重启（或者根据重启策略不再尝试重启）。
5. **Unknown（未知）**：由于某些原因（如节点失联），Kubernetes 无法获取 Pod 的当前状态 。

## pod一直处于pending状态一般有哪些情况，怎么排查？

### 资源不足

- **情况**：节点上的 CPU、内存等资源不足以满足 Pod 的请求。
- 排查方法：
  - 使用 `kubectl describe nodes` 查看节点资源使用情况，重点关注 `Allocatable`（可分配资源）和 `Allocated resources`（已分配资源），对比 Pod 的资源请求量。
  - 查看集群整体资源情况，可通过监控工具（如 Prometheus + Grafana）查看集群资源趋势。

### 调度约束问题

- 情况：
  - **节点选择器（Node Selector）**：Pod 定义了节点选择器，但没有节点匹配该选择器规则。
  - **污点（Taints）与容忍度（Tolerations）**：节点设置了污点，而 Pod 没有相应的容忍度。
- 排查方法：
  - 对于节点选择器，检查 Pod 配置文件中的 `nodeSelector` 字段，确认是否有匹配的节点标签。使用 `kubectl get nodes --show-labels` 查看节点标签。
  - 对于污点和容忍度，使用 `kubectl describe node <node-name>` 查看节点的 Taints 信息，在 Pod 配置文件中查看是否有对应的 Tolerations 设置。

### 镜像拉取问题

- **情况**：镜像拉取失败，可能是镜像地址错误、私有镜像仓库认证信息不正确等。
- 排查方法：
  - 查看 Pod 事件，使用 `kubectl describe pod <pod-name>`，查找与镜像拉取相关的错误信息。
  - 若使用私有镜像仓库，检查 Secret 配置是否正确，以及镜像仓库地址和镜像名称是否无误。

### 网络插件问题

- **情况**：网络插件故障或配置错误，导致 Pod 无法正常分配网络。
- 排查方法：
  - 查看网络插件相关组件的运行状态，如 Calico、Flannel 等，可通过对应组件的命令或查看其 Pod 状态来确认。
  - 检查网络策略是否限制了 Pod 的创建或网络分配。

### 其他问题

- **情况**：如 kube-scheduler 故障、etcd 存储异常等，影响 Pod 正常调度。
- 排查方法：
  - 查看 kube-scheduler 组件状态，检查其日志是否有错误信息。
  - 检查 etcd 集群健康状态，可使用 `etcdctl` 工具进行相关检查 。

## pod的初始化容器是干什么的？

Pod 的初始化容器（Init Containers）是在 Pod 中的主容器（常规容器）启动之前按顺序运行的特殊容器，主要用于在主容器运行前执行一些初始化任务 ，常见用途如下：

### 环境准备

- **配置文件生成**：初始化容器可以根据外部参数或数据生成主容器所需的配置文件。例如，从配置中心拉取基础配置，结合本地的一些变量进行修改和完善后，生成最终供主容器使用的完整配置文件。
- **依赖安装**：如果主容器依赖某些特定的软件包或库，但这些依赖安装过程较为复杂或耗时，初始化容器可以先完成这些依赖的安装工作，为主容器创建好合适的运行环境。

### 数据预处理

- **数据下载**：从外部数据源（如数据库、文件存储服务）下载主容器运行所需的数据到共享卷中，主容器启动后可直接使用这些数据。
- **数据转换**：对下载或已有的数据进行格式转换、清洗等操作，使其符合主容器的处理要求。

### 权限设置与资源初始化

- **权限检查与设置**：初始化容器可以进行一些权限相关的检查和设置工作，确保主容器在运行时具有正确的访问权限，例如创建必要的目录并设置合适的权限。
- **资源初始化**：对共享资源进行初始化操作，如初始化数据库连接池、创建分布式锁等，以便主容器后续能顺利使用这些资源 。

## pod的资源请求、限制如何定义？

更常见的是为 Pod 内的每个容器分别定义资源请求和限制，这样可以更精确地控制每个容器的资源使用。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: my-container-1
    image: nginx:latest
    resources:
      requests:
        cpu: "100m" 
        memory: "32Mi" 
      limits:
        cpu: "200m" 
        memory: "64Mi" 
  - name: my-container-2
    image: busybox
    command: ["sh", "-c", "sleep 3600"]
    resources:
      requests:
        cpu: "50m" 
        memory: "16Mi" 
      limits:
        cpu: "100m" 
        memory: "32Mi" 
```

- `my-container-1` 请求 0.1 个 CPU 核心和 32MB 内存，限制使用 0.2 个 CPU 核心和 64MB 内存。
- `my-container-2` 请求 0.05 个 CPU 核心和 16MB 内存，限制使用 0.1 个 CPU 核心和 32MB 内存。

## pod的定义中有个command和args参数，这两个参数不会 和docker镜像的entrypointc冲突吗

不会。
在pod中定义的command参数用于指定容器的启动命令列表，如果不指定，则默认使用Dockerfile打包
时的启动命令，args参数用于容器的启动命令需要的参数列表；
特别说明：
kubernetes中的command、args其实是实现覆盖dockerfile中的ENTRYPOINT的功能的。当
1、如果command和args均没有写，那么使用Dockerfile的配置；
2、如果command写了但args没写，那么Dockerfile默认的配置会被忽略，执行指定的command；
3、如果command没写但args写了，那么Dockerfile中的ENTRYPOINT的会被执行，使用当前args的参
数；
4、如果command和args都写了，那么Dockerfile会被忽略，执行输入的command和args

## 标签及标签选择器是什么，如何使用

1. **定义**
   - **标签（Label）**：是附加在Kubernetes资源（如Pod、Service等）上的键值对，用于标识和选择对象。
   - **标签选择器（Label Selector）**：用于根据标签来筛选资源，支持基于等式和集合的匹配方式。

标签和标签选择器最重要的使用之一在于，在deployment中，在pod模板中定义pod的标签，然后在
deployment定义标签选择器，这样就通过标签选择器来选择哪些pod是受其控制的，service也是通过标
签选择器来关联哪些pod最后其服务后端pod

## service是如何与pod关联的

答案是通过标签选择器，每一个由deployment创建的pod都带有标签，这样，service就可以定义标签选
择器来关联哪些pod是作为其后端了，就是这样，service就与pod关联在一起了。

## service的域名解析格式、pod的域名解析格式

### Service 域名解析格式

Service 的域名解析格式为：

```
<service-name>.<namespace>.svc.<cluster-domain>
```

例如，一个名为 `my-service` 的 Service 在 `default` 命名空间中，集群域为 `cluster.local`，其完整域名是 `my-service.default.svc.cluster.local`。

### Pod 域名解析格式

Pod 的域名解析格式有以下几种情况：

1. **基于 Pod IP 的域名**：

   ```
   <pod-ip>.<namespace>.pod.<cluster-domain>
   ```

   例如，Pod 的 IP 为 `10.0.95.63`，命名空间为 `default`，集群域为 `cluster.local`，则域名是 `10-0-95-63.default.pod.cluster.local`。

2. **基于控制器名称的域名**（如 Deployment 或 DaemonSet）：

   ```
   <pod-ip>.<controller-name>.<namespace>.svc.<cluster-domain>
   ```

   例如，Pod 的 IP 为 `10.0.95.48`，控制器名称为 `demo-app`，命名空间为 `default`，则域名是 `10-0-95-48.demo-app.default.svc.cluster.local`。

3. **自定义 Hostname 和 Subdomain**： 如果 Pod 配置了 `hostname` 和 `subdomain`，其域名格式为：

   ```
   <hostname>.<subdomain>.<namespace>.svc.<cluster-domain>
   ```

   例如，Pod 的 `hostname` 为 `webapp-1`，`subdomain` 为 `mysubdomain`，命名空间为 `default`，则域名是 `webapp-1.mysubdomain.default.svc.cluster.local`。

## service的类型有哪几种

1. **ClusterIP**：
   - 默认类型。
   - 为 Service 分配一个仅在集群内部可访问的虚拟 IP（ClusterIP）。
   - 只能被集群内部的 Pod 和其他资源访问。
2. **NodePort**：
   - 将 Service 暴露在每个节点的固定端口上（范围通常是 30000-32767）。
   - 可以通过 `<Node-IP>:<NodePort>` 从集群外部访问。
   - 适用于小型集群或开发环境。
3. **LoadBalancer**：
   - 仅在支持外部负载均衡器的云平台上有效（如 AWS、GCP、Azure）。
   - 自动创建一个外部负载均衡器，并将流量转发到 Service。
   - 可以通过负载均衡器的外部 IP 访问。
4. **ExternalName**：
   - 将 Service 映射到一个外部的域名。
   - 不会创建 ClusterIP 或 Pod 端口转发，而是通过 CNAME 记录直接解析到指定的外部域名。
   - 适用于将集群内部的资源指向外部服务。
5. **Headless Service**：
   - 不会分配 ClusterIP，而是直接将 DNS 解析到后端 Pod 的 IP 地址。
   - 适用于需要直接访问 Pod IP 的场景，如 StatefulSet 中的有状态应用。

## 一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？

有两种方式，一种是通过环境变量，另一种是通过service的dns域名方式。
1、环境变量：当pod被创建之后，k8s系统会自动为容器注入集群内有效的service名称和端口号等信息
为环境变量的形式，这样容器应用直接通过取环境变量值就能访问service了，如curl 
http://${WEBAPP_SERVICE_HOST}:{WEBAPP_SERVICE_PORT}
 2、DNS方式：使用dns域名解析的前提是k8s集群内有DNS域名解析服务器，默认k8s中会有一个
CoreDNS作为k8s集群的默认DNS服务器提供域名解析服务器；service的DNS域名表示格式为..svc.，
servicename是service的名称，namespace是service所处的命名空间，clusterdomain是k8s集群设置
的域名后缀，一般默认为 cluster.local ，这样容器应用直接通过service域名就能访问service了，如wget 
http://svc-deployment-nginx.default.svc.cluster.local:80，另外，service的port端口如果定义了名
称，那么port也可以通过DNS进行解析，格式为：....svc

## 如何创建一个service代理外部的服务（在k8s集群内的应用如何访问外部的服务，如数据库服务， 缓存服务等）?

可以通过创建一个没有标签选择器的service来代理集群外部的服务。
1、创建service时不指定selector标签选择器，但需要指定service的port端口、端口的name、端口协议
等，这样创建出来的service因为没有指定标签选择器就不会自动创建endpoint；
2、手动创建一个与service同名的endpoint，endpoint中定义外部服务的IP和端口，endpoint的名称一
定要与service的名称一样，端口协议也要一样，端口的name也要与service的端口的name一样，不然
endpoint不能与service进行关联。
完成以上两步，k8s会自动将service和同名的endpoint进行关联，这样，k8s集群内的应用服务直接访问
这个service就可以相当于访问外部的服务了。

## service、endpoint、kube-proxys三种的关系是什么？

- **Service 与 Endpoint**：Service 定义了一组Pod的访问策略和虚拟IP，Endpoint记录了Service所关联的Pod的真实 IP 和端口，即 Endpoint 是 Service 的后端实际地址列表，为 Service 提供了具体的目标地址。
- **Service 与 kube-proxy**：kube-proxy 负责将发往 Service 虚拟 IP 的流量转发到对应的后端 Pod，实现 Service 的负载均衡和服务发现功能。
- **Endpoint 与 kube-proxy**：kube-proxy 根据 Endpoint 提供的 Pod 地址信息来进行流量转发，当 Endpoint 中的 Pod 地址发生变化时，kube-proxy 会更新其转发规则，确保流量能正确到达新的目标 Pod。

1. **Service** 通过标签选择器找到匹配的 Pod，并生成对应的 **Endpoint**。
2. **Endpoint** 动态更新，反映当前可用的 Pod。
3. **kube-proxy** 监听 **Service** 和 **Endpoint** 的变化，更新节点的网络规则，确保流量正确转发到后端 Pod。

## 无头service和普通的service有什么区别，无头service使用场景是什么

### 区别

- **是否分配 Cluster IP**：普通 Service 会分配一个 Cluster IP 作为固定入口，用于负载均衡和服务发现。无头 Service 则不分配 Cluster IP，直接将请求路由到后端 Pod。
- **DNS 解析**：普通 Service 有一个对应的 DNS 记录指向其 Cluster IP。无头 Service 的 DNS 记录直接解析到后端 Pod 的 IP 地址，返回多个 A 记录对应多个 Pod IP。
- **负载均衡**：普通 Service 会根据负载均衡策略将请求分发到后端 Pod。无头 Service 不进行负载均衡，客户端请求会直接到达具体 Pod。

### 使用场景

- **需要直接访问特定 Pod**：在某些分布式系统中，如 Cassandra、etcd 等，节点之间需要直接通信，使用无头 Service 可让客户端直接连接到特定的节点 Pod。
- **有状态应用**：对于有状态的应用，每个实例有独特的身份和数据，需要固定的网络标识来保证状态的一致性，无头 Service 可为每个 Pod 提供独立的网络身份。
- **多播或广播场景**：在需要进行多播或广播的应用场景中，无头 Service 可使应用直接与多个目标 Pod 进行通信。

