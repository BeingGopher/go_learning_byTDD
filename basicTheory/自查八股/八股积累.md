# 八股积累

## 内存逃逸

Go 的内存逃逸是指在 Go 语言中，本应分配在栈上的变量，由于某些原因被分配到了堆上。以下是关于 Go 内存逃逸的详细介绍：

### 栈与堆的区别

- **栈**：
  - 分配和回收速度快，由编译器自动管理。
  - 变量生命周期与函数绑定，函数结束后自动回收。
  - 适合存储局部变量和小型数据。
- **堆**：
  - 分配和回收速度较慢，需要垃圾回收器（GC）管理。
  - 变量生命周期不固定。
  - 适合存储大型数据或需要跨函数共享的数据。

### 内存逃逸的原因

- **返回局部变量的指针**：如果函数返回一个局部变量的指针，该局部变量会被分配到堆上。例如：

  go复制

  ```go
  func foo() *int {
      x := 42
      return &x
  }
  ```

  在这种情况下，`x` 会被分配到堆上，因为函数返回后它仍然需要存在。

- **闭包捕获外部变量**：如果闭包函数捕获了外部函数的局部变量，这些变量可能会被分配到堆上。例如：

  go复制

  ```go
  func bar() func() {
      y := 42
      return func() {
          fmt.Println(y)
      }
  }
  ```

  在这种情况下，`y` 会被分配到堆上，因为闭包函数可能在 `bar` 函数返回后被调用。

- **接口和切片分配**：接口和切片的底层数据结构可能会导致内存逃逸。例如，将局部变量作为接口参数传递，可能会导致该变量被分配到堆上。

- **大对象分配**：对于大型的数据结构，Go 有时会选择在堆上分配内存，即使它们没有在函数外部被引用。

- **切片和 map 操作**：如果对切片进行操作可能导致其重新分配内存，或者向 map 中插入数据，这些操作可能导致逃逸。

### 内存逃逸的影响

- **性能开销**：堆上的变量需要通过 GC 回收，增加了额外的性能开销。
- **延迟增加**：GC 的执行可能会导致程序暂停（STW），增加延迟。

### 逃逸分析

Go 编译器会在编译阶段对变量生命周期进行分析，决定变量分配在堆还是栈。可以通过以下命令查看哪些变量发生了内存逃逸：

```bash
go build -gcflags '-m' main.go
```

### 优化建议

- **减少不必要的指针传递**：避免使用指针返回局部变量，改为直接返回值。
- **减少动态分配**：使用固定大小的数组或切片，避免频繁扩容。
- **优化接口使用**：尽量使用具体类型，减少接口动态分配。

## case细节

```go
type student struct {
 	Name string
}
func zhoujielun(v interface{}) {
 	switch msg := v.(type) {
 		case *student, student:
 			msg.Name
 	}
}
```

golang中有规定， switch type 的 case T1 ，类型列表只有⼀个，那么 v := m.(type) 中的 v 的类型就是 T1类型。  

如果是 case T1, T2 ，类型列表中有多个，那 v 的类型还是多对应接⼝的类型，也就 是 m 的类型。  所以这⾥ msg 的类型还是 interface{} ，所以他没有 Name 这个字段，编译阶段就会报错。

## json

按照 golang 的语法，⼩写开头的⽅法、属性或  struct 是私有的，同样，在 json 解 码或转码的时候也⽆ 法上线私有属性的转换。 题⽬中是⽆法正常得到 People 的 name 值的。⽽且，私有属性 name 也不应 该加 json 的标签。  